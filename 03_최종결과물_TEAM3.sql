--■■■ 전체 테이블 및 시퀀스 삭제 ■■■--

--○ 전체 테이블 삭제
DROP TABLE ADMIN CASCADE CONSTRAINTS;
DROP TABLE COURSE CASCADE CONSTRAINTS;
DROP TABLE STUDENT CASCADE CONSTRAINTS;
DROP TABLE DROPSTUDENT CASCADE CONSTRAINTS;
DROP TABLE REGISTER CASCADE CONSTRAINTS;
DROP TABLE GIVEUP CASCADE CONSTRAINTS;
DROP TABLE SCORE CASCADE CONSTRAINTS;
DROP TABLE PROFESSOR CASCADE CONSTRAINTS;
DROP TABLE CLASSROOM CASCADE CONSTRAINTS;
DROP TABLE BOOK CASCADE CONSTRAINTS;
DROP TABLE SUBJECT CASCADE CONSTRAINTS;
DROP TABLE OPENCOURSE CASCADE CONSTRAINTS;
DROP TABLE RATIO CASCADE CONSTRAINTS;
DROP TABLE OPENSUBJECT CASCADE CONSTRAINTS;
DROP TABLE DROPPROFESSOR CASCADE CONSTRAINTS;
DROP TABLE NAME1 CASCADE CONSTRAINTS;
DROP TABLE NAME2 CASCADE CONSTRAINTS;
DROP TABLE NAME3 CASCADE CONSTRAINTS;

--○ 전체 시퀀스 삭제
DROP SEQUENCE SEQ_RATIO;
DROP SEQUENCE SEQ_GIVEUP;
DROP SEQUENCE SEQ_DROPSTU;
DROP SEQUENCE SEQ_DROPPRO;

--○ 휴지통 삭제
PURGE RECYCLEBIN;


--■■■ 테이블(TABLE) 생성 ■■■--



--○ STUDENT 테이블 생성
CREATE TABLE STUDENT
( STU_ID    VARCHAR2(10)    -- 학생 ID
, STU_NAME  VARCHAR2(20)    -- 학생명
, STU_SSN   CHAR(14)        -- 주민번호
, STU_TEL   CHAR(13)        -- 전화번호
);
--==>> Table STUDENT이(가) 생성되었습니다.


--○ ADMIN 테이블 생성
CREATE TABLE ADMIN
( ADM_ID    VARCHAR2(10)    -- 관리자 ID
, ADM_PW    VARCHAR2(10)    -- 관리자 PW
);
--==>> Table ADMIN이(가) 생성되었습니다.


--○ PROFESSOR 테이블 생성
CREATE TABLE PROFESSOR
( PRO_ID    VARCHAR(10)    -- 교수자 ID 
, PRO_NAME  VARCHAR2(20)   -- 교수자명
, PRO_SSN   CHAR(14)       -- 주민번호
, PRO_TEL   CHAR(13)       -- 전화번호
);
--==>> Table PROFESSOR이(가) 생성되었습니다.


--○ CLASSROOM 테이블 생성
CREATE TABLE CLASSROOM     -- 강의실TABLE
( CR_ID     VARCHAR2(10)   -- 강의실코드
, CR_NAME   VARCHAR2(100)  -- 강의실명
);
--==>>Table CLASSROOM이(가) 생성되었습니다.


--○ BOOK 테이블 생성
CREATE TABLE BOOK
( BK_ID     VARCHAR2(10)    -- 교재코드
, BK_NAME   VARCHAR2(100)   -- 교재명
);
--==>> Table BOOK이(가) 생성되었습니다.


--○ COURSE 테이블 생성
CREATE TABLE COURSE         -- 과정TABLE
( CS_ID     VARCHAR2(10)    -- 과정코드
, CS_NAME   VARCHAR2(100)   -- 과정명
);
--==>>Table COURSE이(가) 생성되었습니다.


--○ SUBJECT 테이블 생성
CREATE TABLE SUBJECT
( SUB_ID    VARCHAR2(10)    -- 과목코드
, SUB_NAME  VARCHAR2(100)   -- 과목명
);
--==>> Table SUBJECT이(가) 생성되었습니다.


--○ DROPSTUDENT 테이블 생성
CREATE TABLE DROPSTUDENT
( STU_ID        VARCHAR2(10)        -- 학생 ID
, DROP_REASON   VARCHAR2(1000)      -- 탈퇴사유
, DROP_DATE     DATE	DEFAULT SYSDATE -- 탈퇴일자
, DROP_STU_ID   VARCHAR2(10)        -- 탈퇴번호
);
--==>> Table DROPSTUDENT이(가) 생성되었습니다.


--○ OPENCOURSE 테이블 생성
CREATE TABLE OPENCOURSE             -- 개설과정TABLE
( CS_ID     VARCHAR2(10)            -- 과정코드
, OC_ID     VARCHAR2(10)            -- 개설과정코드
, CR_ID     VARCHAR2(10)            -- 강의실코드
, OC_START  DATE                    -- 과정시작
, OC_END    DATE                    -- 과정끝
, CAPACITY  NUMBER(2)               -- 수강정원
);


--○ REGISTER 테이블 생성
CREATE TABLE REGISTER               
( STU_ID    VARCHAR2(10)            -- 학생 ID
, OC_ID     VARCHAR2(10)            -- 개설과정코드
, REG_ID    VARCHAR2(10)            -- 수강신청코드
, REG_DATE  DATE    DEFAULT SYSDATE -- 수강신청일자
);
--==>> Table REGISTER이(가) 생성되었습니다.


--○ OPENSUBJECT 테이블 생성
CREATE TABLE OPENSUBJECT
( OC_ID     VARCHAR2(10)            -- 개설과정코드
, OS_ID     VARCHAR2(10)            -- 개설과목코드
, PRO_ID    VARCHAR2(10)            -- 교수자 ID
, BK_ID     VARCHAR2(10)            -- 교재코드
, SUB_ID    VARCHAR2(10)            -- 과목코드
, OS_START  DATE                    -- 과목시작
, OS_END    DATE                    -- 과목끝
);
--==>> Table OPENSUBJECT이(가) 생성되었습니다.


--○ DROPPROFESSOR 테이블 생성
CREATE TABLE DROPPROFESSOR
( PRO_ID        VARCHAR2(10)            -- 교수자 ID
, DROP_REASON   VARCHAR2(1000)          -- 탈퇴사유
, DROP_DATE     DATE  DEFAULT SYSDATE   -- 탈퇴일자
, DROP_PRO_ID   VARCHAR2(10)            -- 탈퇴코드
);
--==>> Table DROPPROFESSOR이(가) 생성되었습니다.


--○ GIVEUP 테이블 생성
CREATE TABLE GIVEUP
( REG_ID    VARCHAR2(10)         -- 수강신청코드
, GU_DATE   DATE DEFAULT SYSDATE -- 중도포기시점
, GU_ID     VARCHAR2(10)         -- 중도포기코드
);
--==>> Table GIVEUP이(가) 생성되었습니다.


--○ SCORE 테이블 생성
CREATE TABLE SCORE
( OS_ID         VARCHAR2(10)    -- 개설과목코드
, REG_ID        VARCHAR2(10)    -- 수강신청코드
, ATTENDANCE    NUMBER(3)       -- 출결
, PERFORMANCE   NUMBER(3)       -- 실기
, WRITTEN       NUMBER(3)       -- 필기
, SC_ID         VARCHAR2(10)    -- 성적코드
);
--==>>Table SCORE이(가) 생성되었습니다.


--○ RATIO 테이블 생성
CREATE TABLE RATIO
( RATIO_ID      VARCHAR2(10)  -- 배점코드
, OS_ID         VARCHAR2(10)  -- 개설과목코드
, ATTENDANCE    NUMBER(3)     -- 출결 
, PERFORMANCE   NUMBER(3)     -- 실기
, WRITTEN       NUMBER(3)     -- 필기
);
--==>> Table RATIO이(가) 생성되었습니다.


--○ LOG_STUDENT 테이블(학생 로그인 필요 테이블) 생성
CREATE TABLE LOG_STUDENT
AS
SELECT STU_ID "STU_ID", SUBSTR(STU_SSN,8) "STU_PW"
FROM STUDENT;
--==>> Table LOG_STUDENT이(가) 생성되었습니다.


--○ LOG_PROFESSOR 테이블(교수자 로그인 필요 테이블) 생성
CREATE TABLE LOG_PROFESSOR
AS
SELECT PRO_ID "PRO_ID", SUBSTR(PRO_SSN,8) "PRO_PW"
FROM PROFESSOR;
--==>> Table LOG_PROFESSOR이(가) 생성되었습니다.




--■■■ 제약조건(CONSTRAINT) 추가 ■■■--



--○ STUDENT 테이블 제약조건 추가
ALTER TABLE STUDENT
ADD ( CONSTRAINT STUDENT_STU_ID_PK PRIMARY KEY(STU_ID)
    , CONSTRAINT STUDENT_STU_NAME_NN CHECK(STU_NAME IS NOT NULL)
    , CONSTRAINT STUDENT_STU_SSN_NN CHECK(STU_SSN IS NOT NULL) );
--==>> Table STUDENT이(가) 변경되었습니다.


--○ ADMIN 테이블 제약조건 추가
ALTER TABLE ADMIN
ADD ( CONSTRAINT ADMIN_ADM_ID_PK PRIMARY KEY(ADM_ID)
    , CONSTRAINT ADMIN_ADM_PW_NN CHECK(ADM_PW IS NOT NULL) );
--==>> Table ADMIN이(가) 변경되었습니다.


--○ PROFESSOR 테이블 제약조건 추가
ALTER TABLE PROFESSOR
ADD (CONSTRAINT PROFESSOR_PRO_ID_PK PRIMARY KEY(PRO_ID)
   , CONSTRAINT PROFESSOR_PRO_NAME_NN CHECK(PRO_NAME IS NOT NULL)
   , CONSTRAINT PROFESSOR_PRO_SSN_NN CHECK(PRO_SSN IS NOT NULL));
--==>> Table PROFESSOR이(가) 변경되었습니다.


--○ CLASSROOM 테이블 제약조건 추가
ALTER TABLE CLASSROOM
ADD ( CONSTRAINT CLASSROOM_CR_ID_PK   PRIMARY KEY(CR_ID)
         , CONSTRAINT CLASSROOM_CR_NAME_NN CHECK(CR_NAME IS NOT NULL));
--==>> Table CLASSROOM이(가) 변경되었습니다.


--○ BOOK 테이블 제약조건 추가
ALTER TABLE BOOK
ADD ( CONSTRAINT BOOK_BK_ID_PK PRIMARY KEY(BK_ID)
         , CONSTRAINT BOOK_BK_NAME_NN CHECK(BK_NAME IS NOT NULL));
--==>> Table BOOK이(가) 변경되었습니다.


--○ COURSE 테이블 제약조건 추가
ALTER TABLE COURSE
ADD ( CONSTRAINT COURSE_CS_ID_PK   PRIMARY KEY(CS_ID)
         , CONSTRAINT COURSE_CS_ID_NN CHECK(CS_ID IS NOT NULL) );
--==>> Table COURSE이(가) 변경되었습니다.


--○ SUBJECT 테이블 제약조건 추가
ALTER TABLE SUBJECT
ADD (CONSTRAINT SUBJECT_SUB_ID_PK PRIMARY KEY(SUB_ID)
   , CONSTRAINT SUBJECT_SUB_NAME_NN CHECK(SUB_NAME IS NOT NULL));
--==>> Table SUBJECT이(가) 변경되었습니다.


--○ DROPSTUDENT 테이블 제약조건 추가
ALTER TABLE DROPSTUDENT
ADD ( CONSTRAINT DROPSTUDENT_DROP_STU_ID_PK PRIMARY KEY(DROP_STU_ID)
    , CONSTRAINT DROPSTUDENT_STU_ID_FK FOREIGN KEY(STU_ID) REFERENCES STUDENT(STU_ID)
    , CONSTRAINT DROPSTUDENT_STU_ID_NN CHECK(STU_ID IS NOT NULL)
    , CONSTRAINT DROPSTUDENT_DROP_DATE_NN CHECK(DROP_STU_ID IS NOT NULL) );
--==>> Table DROPSTUDENT이(가) 변경되었습니다.
    

--○ OPENCOURSE 테이블 제약조건 추가    
ALTER TABLE OPENCOURSE
ADD ( CONSTRAINT OPENCOURSE_OC_ID_PK   PRIMARY KEY(OC_ID)
    , CONSTRAINT OPENCOURSE_CS_ID_FK    FOREIGN KEY(CS_ID)      REFERENCES COURSE(CS_ID)
    , CONSTRAINT OPENCOURSE_CR_ID_FK    FOREIGN KEY(CR_ID)      REFERENCES CLASSROOM(CR_ID) 
    , CONSTRAINT OPENCOURSE_CS_ID_NN CHECK(CS_ID IS NOT NULL)
    , CONSTRAINT OPENCOURSE_CR_ID_NN CHECK(CR_ID IS NOT NULL)
    , CONSTRAINT OPENCOURSE_OC_START_END_CK CHECK(OC_START<OC_END));
--==>> Table OPENCOURSE이(가) 변경되었습니다.


--○ REGISTER 테이블 제약조건 추가    
ALTER TABLE REGISTER
ADD (CONSTRAINT REGISTER_REG_ID_PK PRIMARY KEY(REG_ID)
   , CONSTRAINT REGISTER_STU_ID_FK FOREIGN KEY(STU_ID) REFERENCES STUDENT(STU_ID)
   , CONSTRAINT REGISTER_OC_ID_FK FOREIGN KEY(OC_ID) REFERENCES OPENCOURSE(OC_ID)
   , CONSTRAINT REGISTER_STU_ID_NN CHECK(STU_ID IS NOT NULL)
   , CONSTRAINT REGISTER_OC_ID_NN CHECK(OC_ID IS NOT NULL)
   , CONSTRAINT REGISTER_REG_DATE_NN CHECK(REG_DATE IS NOT NULL));
--==>> Table REGISTER이(가) 변경되었습니다.


--○ OPENSUBJECT 테이블 제약조건 추가
ALTER TABLE OPENSUBJECT
ADD (CONSTRAINT OPENSUBJECT_OS_ID_PK PRIMARY KEY(OS_ID)
   , CONSTRAINT OPENSUBJECT_OC_ID_FK FOREIGN KEY(OC_ID)    REFERENCES OPENCOURSE(OC_ID)
   , CONSTRAINT OPENSUBJECT_PRO_ID_FK FOREIGN KEY(PRO_ID)  REFERENCES PROFESSOR(PRO_ID)
   , CONSTRAINT OPENSUBJECT_BK_ID_FK FOREIGN KEY(BK_ID)    REFERENCES BOOK(BK_ID)
   , CONSTRAINT OPENSUBJECT_SUB_ID_FK FOREIGN KEY(SUB_ID)  REFERENCES SUBJECT(SUB_ID)
   , CONSTRAINT OPENSUBJECT_OS_ID_NN CHECK(OS_ID IS NOT NULL)
   , CONSTRAINT OPENSUBJECT_PRO_ID_NN CHECK(PRO_ID IS NOT NULL)
   , CONSTRAINT OPENSUBJECT_BK_ID_NN CHECK(BK_ID IS NOT NULL)
   , CONSTRAINT OPENSUBJECT_SUB_ID_NN CHECK(SUB_ID IS NOT NULL)
   , CONSTRAINT OPENSUBJECT_OS_START_END_CK CHECK(OS_START<OS_END));
--==>> Table OPENSUBJECT이(가) 변경되었습니다.


--○ DROPPROFESSOR 테이블 제약조건 추가  
ALTER TABLE DROPPROFESSOR
ADD (CONSTRAINT DROPPROFESSOR_DROP_PRO_ID_PK PRIMARY KEY(DROP_PRO_ID)
   , CONSTRAINT DROPPROFESSOR_PRO_ID_FK FOREIGN KEY(PRO_ID) REFERENCES PROFESSOR(PRO_ID)
   , CONSTRAINT DROPPROFESSOR_PRO_ID_NN CHECK(PRO_ID IS NOT NULL)
   , CONSTRAINT DROPPROFESSOR_DROP_DATE_NN CHECK(DROP_DATE IS NOT NULL));
--==>> Table DROPPROFESSOR이(가) 변경되었습니다.


--○ GIVEUP 테이블 제약조건 추가                                  
ALTER TABLE GIVEUP
ADD (CONSTRAINT GIVEUP_GU_ID_PK PRIMARY KEY(GU_ID)
   , CONSTRAINT GIVEUP_REG_ID_FK FOREIGN KEY(REG_ID) REFERENCES REGISTER(REG_ID)
   , CONSTRAINT GIVEUP_REG_ID_NN CHECK(REG_ID IS NOT NULL)
   , CONSTRAINT GIVEUP_GU_DATE_NN CHECK(GU_DATE IS NOT NULL));
--==>> Table GIVEUP이(가) 변경되었습니다.


--○ SCORE 테이블 제약조건 추가
ALTER TABLE SCORE
ADD (CONSTRAINT SCORE_SC_ID_PK PRIMARY KEY(SC_ID)
   , CONSTRAINT SCORE_REG_ID_FK FOREIGN KEY(REG_ID) REFERENCES REGISTER(REG_ID)
   , CONSTRAINT SCORE_OS_ID_FK FOREIGN KEY(OS_ID) REFERENCES OPENSUBJECT(OS_ID)
   , CONSTRAINT SCORE_OS_ID_NN CHECK(OS_ID IS NOT NULL)
   , CONSTRAINT SCORE_REG_ID_NN CHECK(REG_ID IS NOT NULL));
--==>> Table SCORE이(가) 변경되었습니다.


--○ RATIO 테이블 제약조건 추가
ALTER TABLE RATIO
ADD (CONSTRAINT RATIO_RATIO_ID_PK PRIMARY KEY(RATIO_ID)
   , CONSTRAINT RATIO_OS_ID_FK FOREIGN KEY(OS_ID) REFERENCES OPENSUBJECT(OS_ID)
   , CONSTRAINT RATIO_OS_ID_NN CHECK(OS_ID IS NOT NULL)
   , CONSTRAINT RATIO_ATTENDANCE_NN CHECK(ATTENDANCE IS NOT NULL)
   , CONSTRAINT RATIO_PERFORMANCE_NN CHECK(PERFORMANCE IS NOT NULL)
   , CONSTRAINT RATIO_WRITTEN_NN CHECK(WRITTEN IS NOT NULL)); 
--==>> Table RATIO이(가) 변경되었습니다.



--■■■ 시퀀스(SEQUENCE) 생성 ■■■--



--○ SEQ_RATIO 시퀀스(SEQUENCE) 생성
CREATE SEQUENCE SEQ_RATIO  -- 시퀀스 생성 기본 구문(MSSQL의 IDENTITY와 동일한 개념)
START WITH 1               -- 시작값
INCREMENT BY 1             -- 증가값
NOMAXVALUE                 -- 최대값 제한 없음
NOCACHE;                   -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_RATIO이(가) 생성되었습니다.


--○ SEQ_GIVEUP 시퀀스(SEQUENCE) 생성
CREATE SEQUENCE SEQ_GIVEUP -- 시퀀스 생성 기본 구문(MSSQL의 IDENTITY와 동일한 개념)
START WITH 1              -- 시작값
INCREMENT BY 1            -- 증가값
NOMAXVALUE                -- 최대값 제한 없음
NOCACHE;                  -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_GIVEUP이(가) 생성되었습니다.


--○ SEQ_DROPSTU 시퀀스(SEQUENCE) 생성
CREATE SEQUENCE SEQ_DROPSTU -- 시퀀스 생성 기본 구문(MSSQL의 IDENTITY와 동일한 개념)
START WITH 1               -- 시작값
INCREMENT BY 1             -- 증가값
NOMAXVALUE                 -- 최대값 제한 없음
NOCACHE;                   -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_DROPSTU이(가) 생성되었습니다.


--○ SEQ_DROPPRO 시퀀스(SEQUENCE) 생성
CREATE SEQUENCE SEQ_DROPPRO -- 시퀀스 생성 기본 구문(MSSQL의 IDENTITY와 동일한 개념)
  START WITH 1              -- 시작값
  INCREMENT BY 1            -- 증가값
  NOMAXVALUE                -- 최대값 제한 없음           
  MINVALUE 1                -- 최소값
  NOCYCLE;                  -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_DROPPRO이(가) 생성되었습니다.



--■■■ 함수(FUNCTION) 생성 ■■■--



--○ 어느 테이블에 어떤 코드가 있으면 1, 없으면 0 리턴하는 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION IS_CONTAIN
( TABLE_NAME         IN VARCHAR2
, CODE_OR_ID_COLUMN  IN VARCHAR2
, CODE_OR_ID         IN VARCHAR2
)
RETURN NUMBER
IS
    V_RESULT    NUMBER;
    V_SQL       VARCHAR2(1000);
BEGIN
    V_SQL := 'SELECT NVL2(MAX(' || CODE_OR_ID_COLUMN || '), 1,0) FROM ' || TABLE_NAME || ' WHERE ' || CODE_OR_ID_COLUMN || ' = ''' || CODE_OR_ID ||'''' ;
    
    EXECUTE IMMEDIATE V_SQL INTO V_RESULT;
    
    RETURN V_RESULT;
END;
--==>> Function IS_CONTAIN이(가) 컴파일되었습니다.


--○ 테이블에 코드값 +1 해주는 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION ADD_ID
( TABLE_NAME        IN VARCHAR2
, CODE_OR_ID_COLUMN IN VARCHAR2
, CODE_OR_ID_FORMAT IN VARCHAR2
)
RETURN VARCHAR2
IS
    V_RESULT    VARCHAR2(10);
    V_SQL       VARCHAR2(1000);
    V_SUFFIX    VARCHAR2(10);
BEGIN
    IF (LENGTH(CODE_OR_ID_FORMAT)=5)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT ''' || V_SUFFIX || ''' || LPAD( TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('|| CODE_OR_ID_COLUMN ||', 3))), 0) + 1), 3, ''0'') FROM ' || TABLE_NAME ;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=7)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 1);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',5))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=8 AND SUBSTR(CODE_OR_ID_FORMAT,1 ,1)='S')
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 1);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',5))), 0 ) + 1), 4, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=8)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=9)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 4, ''0'') FROM '|| TABLE_NAME;
    END IF;
    
    EXECUTE IMMEDIATE V_SQL INTO V_RESULT;
    
    RETURN V_RESULT;
END;
--==>> Function ADD_ID이(가) 컴파일되었습니다.



--■■■ 뷰(VIEW) 생성 ■■■--


--○ 통합 뷰(VIEW) 생성
CREATE OR REPLACE VIEW ALL_STATUS
AS
SELECT STU.STU_ID "STU_ID"
     , OS.OS_ID "OS_ID"
     , OS.PRO_ID "PRO_ID"
     , CS.CS_ID "CS_ID"
     , CR.CR_ID "CR_ID"
     , OC.OC_ID "OC_ID"
     , SUB.SUB_NAME"과목명"
     , CS.CS_NAME "과정명"
     , OS.OS_START "OS_START"
     , OS.OS_END "OS_END"
     , OC.OC_START "OC_START"
     , OC.OC_END "OC_END"
     , TO_CHAR(OS.OS_START, 'YYYY-MM-DD') || ' ~ ' || TO_CHAR(OS.OS_END, 'YYYY-MM-DD')"과목기간"
     , TO_CHAR(OC.OC_START, 'YYYY-MM-DD') || ' ~ ' || TO_CHAR(OC.OC_END, 'YYYY-MM-DD')"과정기간"
     , BK.BK_NAME "교재명"
     , PRO.PRO_NAME "교수자명"
     , CR.CR_NAME "강의실"
     , STU.STU_NAME "학생명"
     , SC.ATTENDANCE "출결"
     , SC.PERFORMANCE "실기"
     , SC.WRITTEN "필기"
     , SC.ATTENDANCE + SC.PERFORMANCE + SC.WRITTEN "총점"
     , RANK() OVER(PARTITION BY OS.OS_ID ORDER BY (SC.ATTENDANCE + SC.PERFORMANCE + SC.WRITTEN) DESC) "등수"
     , NVL2(GU.GU_DATE, '중도포기', NULL) "중도포기여부"
     , CASE 
            WHEN OS_START > SYSDATE THEN '강의예정'
            WHEN OS_START < SYSDATE AND OS_END > SYSDATE THEN '강의중'
            WHEN OS_END < SYSDATE THEN '강의종료'
       ELSE '미등록'
       END "강의진행여부"
FROM REGISTER REG JOIN OPENSUBJECT OS   ON REG.OC_ID = OS.OC_ID
                  LEFT JOIN SCORE SC    ON (REG.REG_ID = SC.REG_ID AND OS.OS_ID = SC.OS_ID)
                  JOIN SUBJECT SUB      ON OS.SUB_ID = SUB.SUB_ID
                  JOIN BOOK BK          ON OS.BK_ID = BK.BK_ID
                  JOIN OPENCOURSE OC    ON OS.OC_ID = OC.OC_ID
                  JOIN STUDENT STU      ON REG.STU_ID = STU.STU_ID
                  JOIN COURSE CS        ON OC.CS_ID = CS.CS_ID
                  JOIN PROFESSOR PRO    ON OS.PRO_ID = PRO.PRO_ID
                  JOIN CLASSROOM CR     ON OC.CR_ID = CR.CR_ID
                  LEFT JOIN GIVEUP GU   ON REG.REG_ID = GU.REG_ID;
--==>> View ALL_STATUS이(가) 생성되었습니다.
              
                  
--■■■ 트리거(TRIGGER) 생성 ■■■--

 
 
CREATE OR REPLACE TRIGGER TRG_OPENCOURSE_DELETE
    BEFORE
    DELETE ON OPENCOURSE
    FOR EACH ROW
DECLARE
    V_OC_START  OPENCOURSE.OC_START%TYPE;
    V_OC_END    OPENCOURSE.OC_END%TYPE;
    
    USER_DEFINE_ERROR EXCEPTION;
BEGIN   
    IF SYSDATE<:OLD.OC_START      -- 현재날짜보다 미래인 수강시작날짜
        THEN DELETE
             FROM REGISTER
             WHERE OC_ID = :OLD.OC_ID;
             DELETE
             FROM OPENSUBJECT
             WHERE OC_ID = :OLD.OC_ID;
    ELSE
        RAISE USER_DEFINE_ERROR;
    END IF;

    -- 예외처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '삭제불가');  
            
END;
--==>> Trigger TRG_OPENCOURSE_DELETE이(가) 컴파일되었습니다.


--○ 개설과목을 삭제 할때 딸려있는 배점정보도 같이 지우는 트리거(TRIGGER) 생성
--   과목 시작 전에 배점 입력한 경우가 있을 수 있어 트리거 달아 놓음
--   성적은 과목이 끝나야 입력가능 -> 시작된 과목은 삭제를 못하므로 고려하지 않아도됨
CREATE OR REPLACE TRIGGER TRG_OPENSUBJECT_DELETE
    BEFORE
    DELETE ON OPENSUBJECT
    FOR EACH ROW
DECLARE
BEGIN
    DELETE
    FROM RATIO
    WHERE OS_ID = :OLD.OS_ID;
END;
--==>> Trigger TRG_OPENSUBJECT_DELETE이(가) 컴파일되었습니다.





--■■■ 프로시저(PROCEDURE) 생성 ■■■--



--○ 학생 정보(학생명, 주민번호, 전화번호) INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_STUDENT_INSERT
( V_STU_NAME    IN  STUDENT.STU_NAME%TYPE
, V_STU_SSN     IN  STUDENT.STU_SSN%TYPE
, V_STU_TEL     IN  STUDENT.STU_TEL%TYPE
)
IS
    V_STU_ID            STUDENT.STU_ID%TYPE;
    V_STU_ID_NUM        NUMBER(3);
    ISNULL_STU_SSN      NUMBER(1);
    ISNULL_DROP_STU_ID  NUMBER(1);
    V_DROP_STU_ID  STUDENT.STU_ID%TYPE;
    V_DROP_STU_ID2 STUDENT.STU_ID%TYPE;
    V_DROP_STU_ID3 STUDENT.STU_ID%TYPE;
    
    REENTRANCE_ERROR    EXCEPTION;
    NUM_OVER_ERROR      EXCEPTION;
BEGIN
     IF (V_STU_ID_NUM > 9999)         -- ID숫자가 9999이상이 되면 에러
        THEN RAISE NUM_OVER_ERROR;
     END IF;

    -- 입력한 주민번호와 중복된 주민번호와 아이디가 존재하면 1, 존재하지 않으면 0
    SELECT NVL2(MAX(STU_SSN), 1, 0), MAX(STU_ID) INTO ISNULL_STU_SSN, V_STU_ID
    FROM STUDENT
    WHERE STU_SSN = V_STU_SSN;

    SELECT NVL2(MAX(DROP_STU_ID), 1, 0) INTO ISNULL_DROP_STU_ID
    FROM DROPSTUDENT
    WHERE STU_ID = V_STU_ID;
    
    IF(ISNULL_STU_SSN=0) -- 신규가입
        THEN -- ID숫자부분 붙이기
            SELECT NVL(MAX(TO_NUMBER(SUBSTR(STU_ID,5))), 0 ) + 1 INTO V_STU_ID_NUM
            FROM STUDENT;
            V_STU_ID := 'S'||TO_CHAR(SYSDATE,'YY')||'_'||LPAD(TO_CHAR(V_STU_ID_NUM), 4, '0');
        
            -- 새 정보 INSERT하기
            INSERT INTO STUDENT(STU_ID, STU_NAME, STU_SSN, STU_TEL)
            SELECT V_STU_ID, V_STU_NAME, V_STU_SSN, V_STU_TEL
            FROM DUAL
            WHERE NOT EXISTS (SELECT * FROM STUDENT WHERE STU_SSN=V_STU_SSN ); 

    ELSIF(ISNULL_STU_SSN=1 AND ISNULL_DROP_STU_ID=1)-- 탈퇴했다가 1년 지나기 전 다시가입
        THEN  -- 탈퇴한 회원이 재가입할때 DROPSTUDENT에서 레코드를 지우는 과정
            SELECT STU_ID INTO V_DROP_STU_ID 
            FROM STUDENT 
            WHERE STU_SSN=V_STU_SSN;         -- 주민번호로 STUDENT에서 STU_ID 추출
            
            SELECT STU_ID INTO V_DROP_STU_ID2 
            FROM DROPSTUDENT 
            WHERE STU_ID=V_DROP_STU_ID; -- STU_ID가 DROPSTUDENT에 있으면(탈퇴한 회원이면) STU_ID를 V_DROP_STU_ID2에 담는다
            
                IF(V_DROP_STU_ID=V_DROP_STU_ID2)    -- STUDENT 테이블 STU_ID = DROPSTUDENT 테이블 STU_ID 이면
                    THEN V_DROP_STU_ID3 := V_DROP_STU_ID;   -- 정보를 V_DROP_STU_ID3에 담는다
                END IF;
         
            DELETE
            FROM DROPSTUDENT
            WHERE STU_ID=V_DROP_STU_ID3;    -- V_DROP_STU_ID3이 존재한다면 DROPSTUDENT 테이블에서 정보를 삭제
            
            UPDATE STUDENT
            SET STU_NAME =V_STU_NAME, STU_TEL=V_STU_TEL
            WHERE STU_ID=V_DROP_STU_ID3;    -- V_DROP_STU_ID3이 존재한다면 주민번호와 STU_ID를 제외한 STUDENT의 정보 입력값으로 수정

    ELSIF(ISNULL_STU_SSN=1 AND ISNULL_DROP_STU_ID=0) -- 이미 가입된 사람이 재가입하려고 하는 경우
        THEN RAISE REENTRANCE_ERROR;
    END IF;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN NUM_OVER_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '입력가능한 숫자범위를 넘어섰습니다. DB관리자를 호출하세요');
                 ROLLBACK;
        WHEN REENTRANCE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20004, '이미 가입한 정보가 존재합니다');
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_STUDENT_INSERT이(가) 컴파일되었습니다.


--○ 교수자 정보(교수ID,교수명,주민번호,전화번호) INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_PROFESSOR_INSERT
( V_PRO_NAME    IN  PROFESSOR.PRO_NAME%TYPE
, V_PRO_SSN     IN  PROFESSOR.PRO_SSN%TYPE
, V_PRO_TEL     IN  PROFESSOR.PRO_TEL%TYPE
)
IS
    V_PRO_ID            PROFESSOR.PRO_ID%TYPE;
    V_PRO_ID_NUM        NUMBER(3);
    ISNULL_PRO_SSN      NUMBER(1);
    ISNULL_DROP_PRO_ID  NUMBER(1);
    V_DROP_PRO_ID  PROFESSOR.PRO_ID%TYPE;
    V_DROP_PRO_ID2 PROFESSOR.PRO_ID%TYPE;
    V_DROP_PRO_ID3 PROFESSOR.PRO_ID%TYPE;
       
    REENTRANCE_ERROR    EXCEPTION;
    NUM_OVER_ERROR      EXCEPTION;
BEGIN
     IF (V_PRO_ID_NUM > 999)         -- ID숫자가 999이상이 되면 에러
        THEN RAISE NUM_OVER_ERROR;
     END IF;

    SELECT NVL2(MAX(PRO_SSN), 1, 0), MAX(PRO_ID) INTO ISNULL_PRO_SSN, V_PRO_ID
    FROM PROFESSOR
    WHERE PRO_SSN = V_PRO_SSN;
    
    SELECT NVL2(MAX(DROP_PRO_ID), 1, 0) INTO ISNULL_DROP_PRO_ID
    FROM DROPPROFESSOR
    WHERE PRO_ID = V_PRO_ID;
    
    IF(ISNULL_PRO_SSN=0) -- 신규가입
        THEN -- ID숫자부분 붙이기
            SELECT NVL(MAX(TO_NUMBER(SUBSTR(PRO_ID,6))), 0 ) + 1 INTO V_PRO_ID_NUM
            FROM PROFESSOR;
            V_PRO_ID := 'PR'||TO_CHAR(SYSDATE,'YY')||'_'||LPAD(TO_CHAR(V_PRO_ID_NUM), 3, '0');
        
            -- 새 정보 INSERT
            INSERT INTO PROFESSOR(PRO_ID, PRO_NAME, PRO_SSN, PRO_TEL)
            SELECT V_PRO_ID, V_PRO_NAME, V_PRO_SSN, V_PRO_TEL
            FROM DUAL
            WHERE NOT EXISTS (SELECT * FROM PROFESSOR WHERE PRO_SSN=V_PRO_SSN ); 

    ELSIF(ISNULL_PRO_SSN=1 AND ISNULL_DROP_PRO_ID=1) -- 탈퇴했다가 1년 지나기 전 다시가입
        THEN  -- 탈퇴한 회원이 재가입할때 DROPPROFESSOR에서 레코드를 지우는 과정
            SELECT PRO_ID INTO V_DROP_PRO_ID 
            FROM PROFESSOR 
            WHERE PRO_SSN=V_PRO_SSN;     -- 주민번호로 PROFESSOR에서 PRO_ID 추출
            
            SELECT PRO_ID INTO V_DROP_PRO_ID2 
            FROM DROPPROFESSOR 
            WHERE PRO_ID=V_DROP_PRO_ID; -- PRO_ID가 DROPPROFESSOR에 있으면(탈퇴한 회원이면) PRO_ID를 V_DROP_PRO_ID2에 담는다
            
                IF(V_DROP_PRO_ID=V_DROP_PRO_ID2)    -- PROFESSOR 테이블 PRO_ID = DROPPROFESSOR 테이블 PRO_ID 이면
                    THEN V_DROP_PRO_ID3 := V_DROP_PRO_ID;   -- 정보를 V_DROP_PRO_ID3에 담는다
                END IF;
         
            DELETE
            FROM DROPPROFESSOR
            WHERE PRO_ID=V_DROP_PRO_ID3;    -- V_DROP_PRO_ID3이 존재한다면 DROPPROFESSOR 테이블에서 정보를 삭제하고
            
            UPDATE PROFESSOR
            SET PRO_NAME =V_PRO_NAME, PRO_TEL=V_PRO_TEL
            WHERE PRO_ID=V_DROP_PRO_ID3;    -- V_DROP_PRO_ID3이 존재한다면 주민번호와 PRO_ID를 제외한 PROFESSOR의 정보 입력값으로 수정

    ELSIF(ISNULL_PRO_SSN=1 AND ISNULL_DROP_PRO_ID=0) -- 이미 가입된 사람이 재가입하려고 하는 경우
        THEN RAISE REENTRANCE_ERROR;
    END IF;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN NUM_OVER_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '입력가능한 숫자범위를 넘어섰습니다. DB관리자를 호출하세요');
                 ROLLBACK;
        WHEN REENTRANCE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20004, '이미 가입한 정보가 존재합니다');
       
END;
--==>> Procedure PRC_PROFESSOR_INSERT이(가) 컴파일되었습니다.


--○ OPENCOURSE UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPENCOURSE_UPDATE
( V_OC_ID       IN OPENCOURSE.OC_ID%TYPE
, V_OC_START    IN OPENCOURSE.OC_START%TYPE
, V_OC_END      IN OPENCOURSE.OC_END%TYPE
, V_CAPACITY    IN OPENCOURSE.CAPACITY%TYPE
)
IS
    V_OC_START_OLD  OPENCOURSE.OC_START%TYPE;
    V_OC_END_OLD    OPENCOURSE.OC_END%TYPE;
    
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT OC_START, OC_END INTO V_OC_START_OLD, V_OC_END_OLD
    FROM OPENCOURSE
    WHERE OC_ID = V_OC_ID;

    IF SYSDATE>=V_OC_START              -- 수강시작일보다 이후인 경우 예외발생
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    UPDATE OPENCOURSE
    SET OC_START = V_OC_START, OC_END = V_OC_END, CAPACITY = V_CAPACITY
    WHERE OC_ID = V_OC_ID;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '수정불가');     
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_OPENCOURSE_UPDATE이(가) 컴파일되었습니다.


--○ 교수자 정보 DELETE(DROPPROFESSOR 테이블로 INSERT 처리) 프로시저
CREATE OR REPLACE PROCEDURE PRC_DROPPRO_INSERT
( V_PRO_ID      IN PROFESSOR.PRO_ID%TYPE
, V_DROP_REASON IN DROPPROFESSOR.DROP_REASON%TYPE)
IS  
    V_OS_END      OPENSUBJECT.OS_END%TYPE;
    V_OS_ID       OPENSUBJECT.OS_ID%TYPE;
    ISNULL_PRO_ID NUMBER(1);
    
    OPENCOURSING_PRO_DROP_ERROR   EXCEPTION;        
BEGIN

    SELECT NVL2(MAX(PRO_ID), 1, 0) INTO ISNULL_PRO_ID
    FROM OPENSUBJECT
    WHERE PRO_ID = V_PRO_ID;
    
    IF(ISNULL_PRO_ID=0)
        THEN INSERT INTO DROPPROFESSOR(PRO_ID, DROP_REASON, DROP_PRO_ID)
             VALUES(V_PRO_ID, V_DROP_REASON, SEQ_DROPPRO.NEXTVAL);
    ELSIF(ISNULL_PRO_ID=1)
        THEN SELECT OS_ID INTO V_OS_ID 
             FROM OPENSUBJECT 
             WHERE PRO_ID=V_PRO_ID;
             
             SELECT OS_END INTO V_OS_END 
             FROM OPENSUBJECT 
             WHERE OS_ID=V_OS_ID; 
             
             IF (SYSDATE<=V_OS_END)
                THEN RAISE OPENCOURSING_PRO_DROP_ERROR;
                ELSE INSERT INTO DROPPROFESSOR(PRO_ID, DROP_REASON, DROP_PRO_ID)
                     VALUES(V_PRO_ID, V_DROP_REASON, SEQ_DROPPRO.NEXTVAL);
             END IF;         
    END IF;
    
   -- 커밋
   COMMIT;    
    
    -- 예외처리
    EXCEPTION
        WHEN OPENCOURSING_PRO_DROP_ERROR
            THEN RAISE_APPLICATION_ERROR(-20003, '강의중인 교수는 삭제할 수 없습니다');
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;    
END;
--==>> Procedure PRC_DROPPRO_INSERT이(가) 컴파일되었습니다.


--○ 탈퇴 학생 DELETE 프로시저
CREATE OR REPLACE PROCEDURE PRC_DROPSTU_INSERT
( V_STU_ID      IN STUDENT.STU_ID%TYPE
, V_DROP_REASON IN DROPSTUDENT.DROP_REASON%TYPE)
IS  
    V_OC_END   OPENCOURSE.OC_END%TYPE;
    V_OC_START OPENCOURSE.OC_START%TYPE;
    V_OC_ID     REGISTER.OC_ID%TYPE;
    ISNULL_STU_ID   NUMBER(1);
    
    OPENCOURSING_STU_DROP_ERROR   EXCEPTION;
BEGIN

    SELECT NVL2(MAX(STU_ID), 1, 0) INTO ISNULL_STU_ID
    FROM REGISTER
    WHERE STU_ID = V_STU_ID;
    
    IF(ISNULL_STU_ID=0)
        THEN INSERT INTO DROPSTUDENT(STU_ID, DROP_REASON, DROP_STU_ID)
             VALUES(V_STU_ID, V_DROP_REASON, SEQ_DROPSTU.NEXTVAL);
    ELSIF(ISNULL_STU_ID=1)
        THEN SELECT OC_ID INTO V_OC_ID 
             FROM REGISTER 
             WHERE STU_ID=V_STU_ID;
             
             SELECT OC_END INTO V_OC_END 
             FROM OPENCOURSE 
             WHERE OC_ID=V_OC_ID;
             
             SELECT OC_START INTO V_OC_START 
             FROM OPENCOURSE 
             WHERE OC_ID=V_OC_ID;
             
             IF (V_OC_START<=SYSDATE AND SYSDATE<=V_OC_END)
                THEN RAISE OPENCOURSING_STU_DROP_ERROR;
             ELSE INSERT INTO DROPSTUDENT(STU_ID, DROP_REASON, DROP_STU_ID)
                  VALUES(V_STU_ID, V_DROP_REASON, SEQ_DROPSTU.NEXTVAL);
             END IF;
   END IF;
   
   -- 커밋
   COMMIT;
     
     -- 예외처리   
     EXCEPTION
        WHEN OPENCOURSING_STU_DROP_ERROR
            THEN RAISE_APPLICATION_ERROR(-20003, '수강중인 학생은 삭제할 수 없습니다');
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;    
END;
--==>> Procedure PRC_DROPSTU_INSERT이(가) 컴파일되었습니다.


--○ 사용 가능한 교수 PRINT 쿼리문
SELECT PRO_ID
FROM PROFESSOR
MINUS
SELECT PRO_ID
FROM OPENSUBJECT
WHERE (OS_START<TO_DATE('2019-04-17','YYYY-MM-DD') AND TO_DATE('2019-04-17','YYYY-MM-DD')<OS_END)
   OR (OS_START<TO_DATE('2019-06-17','YYYY-MM-DD') AND TO_DATE('2019-06-17','YYYY-MM-DD')<OS_END);


--○ 개설과목 INSERT 프로시저
--   시작, 끝 기간이 할당될 과정 기간 안에 있는지 검사하기 위해 프로시저 사용
CREATE OR REPLACE PROCEDURE PRC_OPENSUBJECT_INSERT
( V_OC_ID       IN  OPENCOURSE.OC_ID%TYPE
, V_PRO_ID      IN  PROFESSOR.PRO_ID%TYPE
, V_BK_ID       IN  BOOK.BK_ID%TYPE
, V_SUB_ID      IN  SUBJECT.SUB_ID%TYPE
, V_OS_START    IN  OPENSUBJECT.OS_START%TYPE
, V_OS_END      IN  OPENSUBJECT.OS_END%TYPE
)
IS
    V_OS_ID             OPENSUBJECT.OS_ID%TYPE;
    V_OC_START          OPENCOURSE.OC_START%TYPE;
    V_OC_END            OPENCOURSE.OC_END%TYPE;
    
    DATE_RANGE_ERROR    EXCEPTION;
BEGIN
    SELECT OC_START, OC_END INTO V_OC_START, V_OC_END
    FROM OPENCOURSE
    WHERE OC_ID = V_OC_ID;
    
    IF (V_OS_START<V_OC_START)
        THEN RAISE DATE_RANGE_ERROR;
    ELSIF (V_OS_END>V_OC_END)
        THEN RAISE DATE_RANGE_ERROR;
    ELSIF (V_OS_START >= V_OS_END)
        THEN RAISE DATE_RANGE_ERROR;        
    END IF;
    
    SELECT 'OS' || TO_CHAR(SYSDATE, 'YY') || '_' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(OS_ID,6))),0)+1), 4, '0') INTO V_OS_ID
    FROM OPENSUBJECT;
    
    INSERT INTO OPENSUBJECT(OS_ID, OC_ID, PRO_ID, BK_ID, SUB_ID, OS_START, OS_END)
    VALUES
    ( V_OS_ID    -- 개설과목코드
    , V_OC_ID    -- 개설과정코드
    , V_PRO_ID   -- 교수코드
    , V_BK_ID    -- 교재코드
    , V_SUB_ID   -- 과목코드
    , V_OS_START -- 개설과목시작
    , V_OS_END   -- 개설과목끝
    );
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN DATE_RANGE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '과정 범위 안의 날짜를 입력해주세요');
                 ROLLBACK;
        WHEN OTHERS
            THEN RAISE_APPLICATION_ERROR(-20000, '정체불명의 에러 개발자를 호출하세요');
                 ROLLBACK;
END;
--==>> Procedure PRC_OPENSUBJECT_INSERT이(가) 컴파일되었습니다.


--○ 개설과목 UPDATE
--   시작, 끝 기간이 할당될 과정 기간 안에 있는지 검사하기 위해 프로시저 사용
CREATE OR REPLACE PROCEDURE PRC_OPENSUBJECT_UPDATE
( V_OS_ID       IN  OPENSUBJECT.OS_ID%TYPE
, V_OC_ID       IN  OPENCOURSE.OC_ID%TYPE
, V_PRO_ID      IN  PROFESSOR.PRO_ID%TYPE
, V_BK_ID       IN  BOOK.BK_ID%TYPE
, V_SUB_ID      IN  SUBJECT.SUB_ID%TYPE
, V_OS_START    IN  OPENSUBJECT.OS_START%TYPE
, V_OS_END      IN  OPENSUBJECT.OS_END%TYPE
)
IS
    V_OC_START          OPENCOURSE.OC_START%TYPE;
    V_OC_END            OPENCOURSE.OC_END%TYPE;
    
    DATE_RANGE_ERROR    EXCEPTION;
BEGIN
    SELECT OC_START, OC_END INTO V_OC_START, V_OC_END
    FROM OPENCOURSE
    WHERE OC_ID = V_OC_ID;
    
    IF (V_OS_START<V_OC_START)
        THEN RAISE DATE_RANGE_ERROR;
    ELSIF (V_OS_END>V_OC_END)
        THEN RAISE DATE_RANGE_ERROR;
    ELSIF (V_OS_START >= V_OS_END)
        THEN RAISE DATE_RANGE_ERROR;        
    END IF;
    
    UPDATE OPENSUBJECT
    SET OC_ID = V_OC_ID
      , PRO_ID = V_PRO_ID
      , BK_ID = V_BK_ID
      , SUB_ID = V_SUB_ID
      , OS_START = V_OS_START 
      , OS_END = V_OS_END
    WHERE OS_ID = V_OS_ID;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN DATE_RANGE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '과정 범위 안의 날짜를 입력해주세요');
                 ROLLBACK;
        WHEN OTHERS
            THEN RAISE_APPLICATION_ERROR(-20000, '정체불명의 에러 개발자를 호출하세요');
                 ROLLBACK;
END;
--==>> Procedure PRC_OPENSUBJECT_UPDATE이(가) 컴파일되었습니다.


--○ 개설과목 DELETE 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPENSUBJECT_DELETE
(   V_OS_ID    IN  OPENSUBJECT.OS_ID%TYPE
)
IS
    V_OS_START  OPENSUBJECT.OS_START%TYPE;
    
    ALREADY_OPEN_CANNOT_DELETE EXCEPTION;
BEGIN
    SELECT OS_START INTO V_OS_START
    FROM OPENSUBJECT
    WHERE OS_ID = V_OS_ID;
    
    IF (SYSDATE > V_OS_START)
        THEN RAISE ALREADY_OPEN_CANNOT_DELETE;
    END IF;

    DELETE
    FROM OPENSUBJECT
    WHERE OS_ID = V_OS_ID;
    
    EXCEPTION
        WHEN ALREADY_OPEN_CANNOT_DELETE
            THEN RAISE_APPLICATION_ERROR(-20000, '이미 진행된/진행중인 과목은 삭제할 수 없습니다.');
                 ROLLBACK;
        WHEN OTHERS
            THEN RAISE_APPLICATION_ERROR(-20000, '정체불명의 에러 개발자를 호출하세요');
                 ROLLBACK;
END;
--==>> Procedure PRC_OPENSUBJECT_DELETE이(가) 컴파일되었습니다.


--○ 수강신청 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_REGISTER_INSERT
( V_STU_ID   IN STUDENT.STU_ID%TYPE
, V_OC_ID    IN OPENCOURSE.OC_ID%TYPE)
IS
    V_REG_ID       REGISTER.REG_ID%TYPE;
    V_REG_ID_NUM   NUMBER(4);
    V_OC_START     OPENCOURSE.OC_START%TYPE;
    V_CAPACITY     OPENCOURSE.CAPACITY%TYPE;
    V_NOW          OPENCOURSE.CAPACITY%TYPE;
  
 OC_START_ERROR EXCEPTION;
 OC_START_ERROR2 EXCEPTION;

BEGIN
    -- 과정에서 시작날짜 가져오기
    SELECT OC_START INTO V_OC_START FROM OPENCOURSE WHERE OC_ID=V_OC_ID;
       
    -- 과정시작하고나서 등록하면 에러
    IF (SYSDATE>=V_OC_START)
        THEN RAISE OC_START_ERROR;
    END IF;
    
    SELECT CAPACITY INTO V_CAPACITY 
    FROM OPENCOURSE 
    WHERE OC_ID = V_OC_ID;
    
    SELECT COUNT(*) INTO V_NOW 
    FROM REGISTER  
    WHERE OC_ID = V_OC_ID;
       
    IF (V_CAPACITY = V_NOW)
        THEN RAISE OC_START_ERROR2;
    END IF;   
       
    -- REG_ID의 숫자부분 만들기
    SELECT NVL(MAX(TO_NUMBER(SUBSTR(REG_ID,6))), 0 ) + 1 INTO V_REG_ID_NUM
    FROM REGISTER;

    -- REG_ID생성
    V_REG_ID := 'RG'||TO_CHAR(SYSDATE,'YY')||'_'||LPAD(TO_CHAR(V_REG_ID_NUM), 4, '0');

    -- INSERT하기
    INSERT INTO REGISTER(STU_ID, OC_ID, REG_ID)
    VALUES (V_STU_ID, V_OC_ID, V_REG_ID);
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN OC_START_ERROR
            THEN RAISE_APPLICATION_ERROR(-20002, '과정 시작일이 지난 과정은 수강신청할 수 없습니다');
                 ROLLBACK;
        WHEN OC_START_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20020, '수강인원 초과입니다.');
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_REGISTER_INSERT이(가) 컴파일되었습니다.


--○ 수강신청이력 DELETE 프로시저
CREATE OR REPLACE PROCEDURE PRC_REGISTER_DELETE
( V_REG_ID     IN REGISTER.REG_ID%TYPE 
)
IS
    V_OC_ID       REGISTER.OC_ID%TYPE;
    V_OC_START    OPENCOURSE.OC_START%TYPE;
 
 COURSE_OPEN_ERROR  EXCEPTION;
BEGIN
    SELECT OC_ID    INTO V_OC_ID FROM REGISTER WHERE REG_ID=V_REG_ID;
    SELECT OC_START INTO V_OC_START FROM OPENCOURSE WHERE OC_ID = V_OC_ID;

    IF (SYSDATE>=V_OC_START)            -- 강의가 시작되기 전에만 수강신청이력을 삭제할 수 있음
        THEN RAISE COURSE_OPEN_ERROR;
    END IF;

    DELETE
    FROM REGISTER
    WHERE REG_ID = V_REG_ID;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN COURSE_OPEN_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '과정이 이미 시작되었을 경우 수강신청을 삭제할 수 없습니다.');
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_REGISTER_DELETE이(가) 컴파일되었습니다.


--○ 중도 탈락 테이블 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_GIVEUP_INSERT
( V_STU_ID   IN STUDENT.STU_ID%TYPE
)
IS
    V_OC_ID     OPENCOURSE.OC_ID%TYPE;
    V_OC_START  OPENCOURSE.OC_START%TYPE;
    V_OC_END    OPENCOURSE.OC_END%TYPE;
    V_REG_ID    REGISTER.REG_ID%TYPE;
     
    USER_DEFINE_ERROR EXCEPTION;
BEGIN  
    SELECT REG_ID INTO V_REG_ID
    FROM REGISTER
    WHERE STU_ID = V_STU_ID;
    
    SELECT OC_ID INTO V_OC_ID
    FROM REGISTER
    WHERE STU_ID = V_STU_ID;
    
    SELECT OC_START, OC_END INTO V_OC_START, V_OC_END
    FROM OPENCOURSE
    WHERE OC_ID = V_OC_ID;
    
    IF SYSDATE<V_OC_START      -- 예외발생 진행중인 과정은 수정할 수 없음
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    INSERT INTO GIVEUP(REG_ID, GU_ID)
    VALUES(V_REG_ID, SEQ_GIVEUP.NEXTVAL);
    
    -- 예외처리
    EXCEPTION 
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20000, '중도포기 불가 수강 전입니다.');     
                 ROLLBACK;
        WHEN OTHERS 
            THEN RAISE_APPLICATION_ERROR(-20000, '중도포기 불가 수강 내역이 없습니다.');   
                 ROLLBACK;
END;
--==>> Procedure PRC_GIVEUP_INSERT이(가) 컴파일되었습니다.


--○ 배점 INSERT 프로시저(교수자)
CREATE OR REPLACE PROCEDURE PRC_RATIO_INSERT
( V_OS_ID IN RATIO.OS_ID%TYPE
, V_ATTENDANCE IN RATIO.ATTENDANCE%TYPE
, V_PERFORMANCE IN RATIO.PERFORMANCE%TYPE
, V_WRITTEN IN RATIO.WRITTEN%TYPE
)
IS
    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;   
BEGIN
    IF (V_ATTENDANCE>100 OR V_ATTENDANCE <0) OR 
       (V_PERFORMANCE>100 OR V_PERFORMANCE <0) OR
       (V_WRITTEN>100 OR V_WRITTEN <0)
       THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    IF ( (V_ATTENDANCE+V_PERFORMANCE+V_WRITTEN) != 100 )
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    INSERT INTO RATIO(RATIO_ID,OS_ID,ATTENDANCE,PERFORMANCE,WRITTEN)
    VALUES(SEQ_RATIO.NEXTVAL,V_OS_ID,V_ATTENDANCE,V_PERFORMANCE,V_WRITTEN);
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20013,'배점은 0~100 (%) 만 입력가능합니다.');
                 ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20015,'출결,실기,필기 배점 총 합은 100% 입니다.');
                 ROLLBACK;
        
END;
--==>> Procedure PRC_RATIO_INSERT이(가) 컴파일되었습니다.


--○ 배점 UPDATE 프로시저(교수자)
CREATE OR REPLACE PROCEDURE PRC_RATIO_UPDATE
( V_OS_ID IN RATIO.OS_ID%TYPE
, V_ATTENDANCE IN RATIO.ATTENDANCE%TYPE
, V_PERFORMANCE IN RATIO.PERFORMANCE%TYPE
, V_WRITTEN IN RATIO.WRITTEN%TYPE
)
IS
   USER_DEFINE_ERROR1 EXCEPTION;
   USER_DEFINE_ERROR2 EXCEPTION;
BEGIN
   IF (V_ATTENDANCE>100 OR V_ATTENDANCE <0) OR 
       (V_PERFORMANCE>100 OR V_PERFORMANCE <0) OR
       (V_WRITTEN>100 OR V_WRITTEN <0)
       THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    IF ( (V_ATTENDANCE+V_PERFORMANCE+V_WRITTEN) != 100 )
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    UPDATE RATIO
    SET ATTENDANCE = V_ATTENDANCE
       ,PERFORMANCE = V_PERFORMANCE
       ,WRITTEN = V_WRITTEN
    WHERE OS_ID = V_OS_ID;
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20013,'배점은 0~100 (%) 만 입력가능합니다.');
                 ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20015,'출결,실기,필기 배점 총 합은 100% 입니다.');
                 ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;   

END;
--==>> Procedure PRC_RATIO_UPDATE이(가) 컴파일되었습니다.


--○ 성적 INSERT 프로시저(교수자)
CREATE OR REPLACE PROCEDURE PRC_SCORE_INSERT
(   V_OS_ID IN OPENSUBJECT.OS_ID%TYPE
,   V_STU_ID IN REGISTER.STU_ID%TYPE
,   V_ATTENDANCE IN SCORE.ATTENDANCE%TYPE
,   V_PERFORMANCE IN SCORE.PERFORMANCE%TYPE
,   V_WRITTEN IN SCORE.WRITTEN%TYPE
)
IS
    V_SC_ID SCORE.SC_ID%TYPE ;
    V_SC_ID_NUM NUMBER(10);
    V_REG_ID REGISTER.REG_ID%TYPE;
    V_RA RATIO.ATTENDANCE%TYPE;
    V_RP RATIO.PERFORMANCE%TYPE;
    V_RW RATIO.WRITTEN%TYPE;
    
    V_OC_ID REGISTER.OC_ID%TYPE;
    
    V_OS_END OPENSUBJECT.OS_END%TYPE;
    
    USER_DEFINE_ERROR1 EXCEPTION; 
    USER_DEFINE_ERROR2 EXCEPTION;  
    
BEGIN
   SELECT OS_END INTO V_OS_END FROM OPENSUBJECT WHERE OS_ID = V_OS_ID;  -- OPENSUBJECT 테이블의 OS_END 가져오기
   
   IF ((SYSDATE < V_OS_END) OR (SYSDATE > V_OS_END +3))        -- 성적정정기간 (OS_END 시점부터 3일) 
        THEN RAISE USER_DEFINE_ERROR1;                          
   END IF;

    SELECT OC_ID INTO V_OC_ID FROM OPENSUBJECT WHERE OS_ID = V_OS_ID;
    
    SELECT REG_ID INTO V_REG_ID FROM REGISTER WHERE (STU_ID = V_STU_ID AND OC_ID = V_OC_ID) ;
    -- 학생ID를 이용해서 REG_ID 가져오기
    
    SELECT ATTENDANCE INTO V_RA FROM RATIO WHERE OS_ID = V_OS_ID;
    SELECT PERFORMANCE INTO V_RP FROM RATIO WHERE OS_ID = V_OS_ID;
    SELECT WRITTEN INTO V_RW FROM RATIO WHERE OS_ID = V_OS_ID;
    -- RATIO 테이블에서 개설과목 아이디가 일치하는 배점들 가져오기.
    
    IF (V_ATTENDANCE>100 OR V_ATTENDANCE <0) OR 
       (V_PERFORMANCE>100 OR V_PERFORMANCE <0) OR
       (V_WRITTEN>100 OR V_WRITTEN <0) 
    THEN
       RAISE USER_DEFINE_ERROR2;
    END IF;
    
    
       

    
    
    
    SELECT NVL(MAX(TO_NUMBER(SUBSTR(SC_ID,6))), 0 ) + 1 INTO V_SC_ID_NUM
    FROM SCORE;
    
    
    
            
     V_SC_ID := 'SC'||SUBSTR(TO_CHAR(SYSDATE,'YYYY'),3,2)||'_'
        ||LPAD(TO_CHAR(V_SC_ID_NUM), 4, '0');
 
    
   
    
    INSERT INTO SCORE(SC_ID,OS_ID,REG_ID,ATTENDANCE,PERFORMANCE,WRITTEN)
    VALUES(V_SC_ID,V_OS_ID,V_REG_ID,V_ATTENDANCE * (V_RA / 100)
                ,V_PERFORMANCE * (V_RP / 100),V_WRITTEN * (V_RW / 100));
    
    COMMIT;

    EXCEPTION 
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20010,'성적입력기간이 아닙니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20011,'점수는 0~100 (점) 만 입력가능합니다.');
                 ROLLBACK;
        
    
    -- 과목이 끝났을 때 입력 가능하도록.
    -- 점수 제약 100점 미만으로.
    
END;
--==>> Procedure PRC_SCORE_INSERT이(가) 컴파일되었습니다.


--○ 성적 UPDATE 프로시저(교수자)
CREATE OR REPLACE PROCEDURE PRC_SCORE_UPDATE
( V_OS_ID   IN OPENSUBJECT.OS_ID%TYPE
, V_STU_ID  IN REGISTER.STU_ID%TYPE
, V_ATTENDANCE IN SCORE.ATTENDANCE%TYPE
, V_PERFORMANCE IN SCORE.PERFORMANCE%TYPE
, V_WRITTEN IN SCORE.WRITTEN%TYPE
)
IS
    V_REG_ID REGISTER.REG_ID%TYPE; 
    V_RA RATIO.ATTENDANCE%TYPE;
    V_RP RATIO.PERFORMANCE%TYPE;
    V_RW RATIO.WRITTEN%TYPE;
    V_OS_END OPENSUBJECT.OS_END%TYPE;
    
    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
BEGIN       
    IF (V_ATTENDANCE>100 OR V_ATTENDANCE <0) OR 
       (V_PERFORMANCE>100 OR V_PERFORMANCE <0) OR
       (V_WRITTEN>100 OR V_WRITTEN <0)
       THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    SELECT OS_END INTO V_OS_END 
    FROM OPENSUBJECT 
    WHERE OS_ID = V_OS_ID;

    IF ((SYSDATE < V_OS_END) OR (SYSDATE > V_OS_END +3))
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
     
    SELECT REG_ID INTO V_REG_ID 
    FROM REGISTER 
    WHERE STU_ID = V_STU_ID;
    
    SELECT ATTENDANCE INTO V_RA 
    FROM RATIO 
    WHERE OS_ID = V_OS_ID;
    
    SELECT PERFORMANCE INTO V_RP 
    FROM RATIO 
    WHERE OS_ID = V_OS_ID;
    
    SELECT WRITTEN INTO V_RW 
    FROM RATIO 
    WHERE OS_ID = V_OS_ID;
    
     UPDATE SCORE
     SET ATTENDANCE = V_ATTENDANCE * (V_RA/100)
       , PERFORMANCE = V_PERFORMANCE * (V_RP/100)
       , WRITTEN = V_WRITTEN * (V_RW/100)
     WHERE (REG_ID = V_REG_ID AND OS_ID = V_OS_ID);
    
    -- 커밋
    COMMIT;     
    
    -- 예외처리         
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20011,'점수는 0~100 (점) 만 입력가능합니다.');
                 ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20014,'성적 수정기간이 아닙니다.');
                 ROLLBACK;
END;
--==>> Procedure PRC_SCORE_UPDATE이(가) 컴파일되었습니다.


--○ 성적 DELETE 프로시저(교수자)
CREATE OR REPLACE PROCEDURE PRC_SCORE_DELETE
( V_OS_ID   IN OPENSUBJECT.OS_ID%TYPE
, V_STU_ID  IN REGISTER.STU_ID%TYPE
)
IS
    V_REG_ID REGISTER.REG_ID%TYPE;
    V_OS_END OPENSUBJECT.OS_END%TYPE;
    
    USER_DEFINE_ERROR1 EXCEPTION;    
BEGIN
    SELECT REG_ID INTO V_REG_ID 
    FROM REGISTER 
    WHERE STU_ID = V_STU_ID;
    
    SELECT OS_END INTO V_OS_END 
    FROM OPENSUBJECT 
    WHERE OS_ID = V_OS_ID;

    IF ((SYSDATE < V_OS_END) OR (SYSDATE > V_OS_END +3))
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    DELETE
    FROM SCORE
    WHERE (REG_ID = V_REG_ID AND OS_ID = V_OS_ID);
    
    -- 커밋
    COMMIT;
    
    -- 예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20014,'성적 수정기간이 아닙니다.');
                 ROLLBACK;    
        WHEN OTHERS
            THEN ROLLBACK;  
END;
--==>> Procedure PRC_SCORE_DELETE이(가) 컴파일되었습니다.


--■■■ 함수(FUNCTION) 생성 ■■■--



--○ 테이블에 코드값 +1 해주는 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION ADD_ID
( TABLE_NAME        IN VARCHAR2
, CODE_OR_ID_COLUMN IN VARCHAR2
, CODE_OR_ID_FORMAT IN VARCHAR2
)
RETURN VARCHAR2
IS
    V_RESULT    VARCHAR2(10);
    V_SQL       VARCHAR2(1000);
    V_SUFFIX    VARCHAR2(10);
BEGIN
    IF (LENGTH(CODE_OR_ID_FORMAT)=5)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT ''' || V_SUFFIX || ''' || LPAD( TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('|| CODE_OR_ID_COLUMN ||', 3))), 0) + 1), 3, ''0'') FROM ' || TABLE_NAME ;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=7)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 1);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',5))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=8)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=9)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 4, ''0'') FROM '|| TABLE_NAME;
    END IF;
    
    EXECUTE IMMEDIATE V_SQL INTO V_RESULT;
    
    RETURN V_RESULT;
END;
--==>> Function ADD_ID이(가) 컴파일되었습니다.


--○ 주민번호 생성 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION  FN_MAKE_SSN
RETURN VARCHAR2
IS
    V_YEAR  NUMBER;
    V_MONTH NUMBER;
    V_DAY   NUMBER;
    V_SEX   NUMBER;
    V_ELSE  NUMBER;   
    V_SSN   VARCHAR2(20);
BEGIN
    V_YEAR  := TRUNC(DBMS_RANDOM.VALUE(70, 99));
    V_MONTH := TRUNC(DBMS_RANDOM.VALUE(1, 13));
    V_DAY   := TRUNC(DBMS_RANDOM.VALUE(1, 28));    
    V_SEX   := TRUNC(DBMS_RANDOM.VALUE(1, 3));   
    V_ELSE  := TRUNC(DBMS_RANDOM.VALUE(111111, 999999));
    V_SSN   := TO_CHAR(V_YEAR) || LPAD(TO_CHAR(V_MONTH), 2, '0') || LPAD(TO_CHAR(V_DAY), 2, '0')||'-'||TO_CHAR(V_SEX)||TO_CHAR(V_ELSE);
    
    RETURN V_SSN;
END;
--==>> Function FN_MAKE_SSN이(가) 컴파일되었습니다.


--○ 전화번호 생성 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION FN_MAKE_TEL
RETURN VARCHAR2
IS
    V_MIDDLE    VARCHAR2(4);
    V_END       VARCHAR2(4);
    V_TEL       VARCHAR2(20);
BEGIN
    V_MIDDLE := TRUNC(DBMS_RANDOM.VALUE(1111, 9999));
    V_END    := TRUNC(DBMS_RANDOM.VALUE(1111, 9999));    
    V_TEL    := '010-'||TO_CHAR(V_MIDDLE)||'-'||TO_CHAR(V_END);
    
    RETURN V_TEL;
END;
--==>> Function FN_MAKE_TEL이(가) 컴파일되었습니다.

--○ 코드의 최댓값을 읽고 다음값을 리턴하는 함수(FUNCTION) 생성
CREATE OR REPLACE FUNCTION ADD_ID
( TABLE_NAME        IN VARCHAR2
, CODE_OR_ID_COLUMN IN VARCHAR2
, CODE_OR_ID_FORMAT IN VARCHAR2
)
RETURN VARCHAR2
IS
    V_RESULT    VARCHAR2(10);
    V_SQL       VARCHAR2(1000);
    V_SUFFIX    VARCHAR2(10);
BEGIN
    IF (LENGTH(CODE_OR_ID_FORMAT)=5)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT ''' || V_SUFFIX || ''' || LPAD( TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('|| CODE_OR_ID_COLUMN ||', 3))), 0) + 1), 3, ''0'') FROM ' || TABLE_NAME ;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=7)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 1);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',5))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=8 AND SUBSTR(CODE_OR_ID_FORMAT,1 ,1)='S')
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 1);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',5))), 0 ) + 1), 4, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=8)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 3, ''0'') FROM '|| TABLE_NAME;
    ELSIF (LENGTH(CODE_OR_ID_FORMAT)=9)
        THEN V_SUFFIX := SUBSTR(CODE_OR_ID_FORMAT, 1, 2);
             V_SQL := 'SELECT '''||V_SUFFIX||'''||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||''_''||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR('||CODE_OR_ID_COLUMN||',6))), 0 ) + 1), 4, ''0'') FROM '|| TABLE_NAME;
    END IF;
    
    EXECUTE IMMEDIATE V_SQL INTO V_RESULT;
    
    RETURN V_RESULT;
END;
--==>> Function ADD_ID이(가) 컴파일되었습니다.




--■■■ 샘플 데이터 입력(INSERT) ■■■--



--○ COURSE 샘플 INSERT
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), 'JAVA 개발자 양성과정');
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), '웹콘텐츠 양성과정');
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), '머신러닝 활용 개발 과정');
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), '빅데이터 분석 응용 과정');
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), '어플리케이션 개발 응용 과정');
INSERT INTO COURSE(CS_ID, CS_NAME)
VALUES(ADD_ID('COURSE', 'CS_ID', 'CS000'), '보안 전문가 양성 과정');
--==>> 1 행 이(가) 삽입되었습니다. * 6


--○ CRASSROOM 샘플 INSERT
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'A-강의장');
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'B-강의장');
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'C-강의장');
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'D-강의장');
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'E-강의장');
INSERT INTO CLASSROOM(CR_ID, CR_NAME)
VALUES(ADD_ID('CLASSROOM', 'CR_ID', 'CR000'), 'F-강의장');
--==>> 1 행 이(가) 삽입되었습니다. * 6


--○ BOOK 샘플 INSERT
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), '처음 배우는 JAVA');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), 'ORACLE 마스터하기');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), '기초부터 HTML');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), '쉽게 배우는 CSS');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), 'JAVASCRIPT FOR BEGGINER');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), 'SPRING 프레임워크 2주완성');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), 'C언어 기초');
INSERT INTO BOOK(BK_ID, BK_NAME) 
VALUES(ADD_ID('BOOK', 'BK_ID', 'BK000'), 'JDBC로 데이터베이스 연결하기');
--==>> 1 행 이(가) 삽입되었습니다. * 8


--○ SUBJECT 샘플 INSERT
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'JAVA');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'ORACLE');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'HTML');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'CSS');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'JAVASCRIPT');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'SPRING');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'C');
INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
VALUES(ADD_ID('SUBJECT', 'SUB_ID', 'SB000') , 'JDBC');
--==>> 1 행 이(가) 삽입되었습니다. * 8


--○ PROFESSOR 샘플 INSERT
EXEC PRC_PROFESSOR_INSERT('홍찬호','851124-1113406', '010-8480-7507');
EXEC PRC_PROFESSOR_INSERT('국상혁','861211-1649329', '010-1029-8685');
EXEC PRC_PROFESSOR_INSERT('탁규범','850813-1747684', '010-6264-3039');
EXEC PRC_PROFESSOR_INSERT('용하빈','841023-1959166', '010-7572-4649');
EXEC PRC_PROFESSOR_INSERT('어민준','800712-1259552', '010-5660-3774');

EXEC PRC_PROFESSOR_INSERT('추연후', '740489-1817954', '010-1248-1748');
EXEC PRC_PROFESSOR_INSERT('한철환', '770417-1687814', '010-1217-7789');
EXEC PRC_PROFESSOR_INSERT('최석우', '841111-1857145', '010-1384-3566');
EXEC PRC_PROFESSOR_INSERT('전세민', '860215-1487156', '010-1458-7425');
EXEC PRC_PROFESSOR_INSERT('박단엽', '811214-1471465', '010-1897-6655');

EXEC PRC_PROFESSOR_INSERT('박라정', '770818-2146745', '010-1354-9371');
EXEC PRC_PROFESSOR_INSERT('박예지', '830411-2251476', '010-1811-9448');
EXEC PRC_PROFESSOR_INSERT('전조원', '820619-2417648', '010-1917-6581');
EXEC PRC_PROFESSOR_INSERT('가혜주', '790414-2314847', '010-2848-7657');
EXEC PRC_PROFESSOR_INSERT('임미연', '800114-2517486', '010-1874-7487');

EXEC PRC_PROFESSOR_INSERT('조승표', '830822-1596784', '010-5055-5146');
EXEC PRC_PROFESSOR_INSERT('원광현', '850729-1365947', '010-5650-5674');
EXEC PRC_PROFESSOR_INSERT('허단현', '780507-1587164', '010-9504-9204');
EXEC PRC_PROFESSOR_INSERT('명승구', '720628-1784891', '010-7112-1143');
EXEC PRC_PROFESSOR_INSERT('안상현', '691202-1098614', '010-7496-3151');
--==>> 1 행 이(가) 삽입되었습니다. * 20


--○ 커밋
COMMIT;
--==>> 커밋 완료.




--■■■ 프로시저(PROCEDURE) 생성 ■■■--



--○ 연도, 갯수를 입력받아 해당연도에 n개의 샘플 개설과정 만들기
CREATE OR REPLACE PROCEDURE PRC_OPENCOURSE_SAMPLE
( V_YEAR    IN  NUMBER
, V_NUM     IN  NUMBER
)
IS
    V_MONTH NUMBER;
    V_DAY   NUMBER;
    V_OC_START DATE;
    V_OC_END   DATE;
    V_CS_ID COURSE.CS_ID%TYPE;
    V_CR_ID CLASSROOM.CR_ID%TYPE;
    
    NO_MORE_USABLE_DATA EXCEPTION;
BEGIN
    FOR N IN 1 .. V_NUM LOOP
        V_MONTH := TRUNC(DBMS_RANDOM.VALUE(1, 13));
        V_DAY := TRUNC(DBMS_RANDOM.VALUE(1,28));
        
        V_OC_START := TO_DATE(TO_CHAR(V_YEAR)||'-'||TO_CHAR(V_MONTH)||'-'||TO_CHAR(V_DAY), 'YYYY-MM-DD');
        V_OC_END := ADD_MONTHS(V_OC_START, 6);
         DBMS_OUTPUT.PUT_LINE(V_OC_START||' ~ '||V_OC_END);
        ------------------------------------------------------------------------------------------------------------ 이상없음
        SELECT CS_ID  INTO V_CS_ID
        FROM
        (SELECT CS_ID
        FROM COURSE
        ORDER BY DBMS_RANDOM.VALUE)
        WHERE ROWNUM=1;
        
        SELECT NVL(MAX(CR_ID), 'NO_DATA') INTO V_CR_ID
        FROM
        (SELECT CR_ID
        FROM (SELECT CR_ID
              FROM CLASSROOM
              MINUS   
              SELECT CR_ID
              FROM OPENCOURSE
              WHERE (OC_START < V_OC_START AND V_OC_START<OC_END)
                 OR (OC_START < V_OC_END AND V_OC_END < OC_END))
        ORDER BY DBMS_RANDOM.VALUE)
        WHERE ROWNUM=1;
        
         DBMS_OUTPUT.PUT_LINE(V_CR_ID);
        ------------------------------------------------------------------------------------------------------------ 이상없음
        IF(V_CS_ID='NO_DATA' OR V_CR_ID='NO_DATA')
            THEN DBMS_OUTPUT.PUT_LINE('입력가능한 데이터가 없습니다.');
        ELSE
            INSERT INTO OPENCOURSE(OC_ID, CS_ID, CR_ID, OC_START, OC_END, CAPACITY) 
            VALUES(ADD_ID('OPENCOURSE', 'OC_ID', 'OC19_000'), V_CS_ID, V_CR_ID, V_OC_START, V_OC_END, 20);
        END IF;
        
   END LOOP;  
   /*
   EXCEPTION
       WHEN NO_MORE_USABLE_DATA
           THEN DBMS_OUTPUT.PUT_LINE('입력가능한 데이터가 없습니다.');
       WHEN OTHERS
           THEN RAISE_APPLICATION_ERROR(-20000, '정체불명의 에러 발생. 개발자를 불러주세요');   
    */
END;
--==>> Procedure PRC_OPENCOURSE_SAMPLE이(가) 컴파일되었습니다.


SET SERVEROUTPUT ON;


--○ 개설과정 샘플 INSERT
EXEC PRC_OPENCOURSE_SAMPLE(2017, 10);
EXEC PRC_OPENCOURSE_SAMPLE(2018, 10);
EXEC PRC_OPENCOURSE_SAMPLE(2019, 10);
EXEC PRC_OPENCOURSE_SAMPLE(2020, 10);




--■■■ 프로시저(PROCEDURE) 생성 ■■■--



--○ 개설과목 생성
--   커서로 개설과정을 잡는다. 
--   개설과정당 랜덤으로 3개씩 개설함. 개설 과정과 교재를 모두 다루게 하는 랜덤 변수를 생성(일단 과목별로 교재 1개씩 있다고 가정 - 나중엔 웹/앱에서 고르게 하니까 걱정 안해도됨)
CREATE OR REPLACE PROCEDURE PRC_OPENSUBJECT_SAMPLE
IS
    CURSOR CUR_OPENCOURSE
    IS
    SELECT OC_ID, OC_START
    FROM OPENCOURSE;
    
    V_TEMP2     NUMBER; -- 과목 돌리는 변수
    V_TEMP      NUMBER; -- 과목 갯수 담아둠
    V_NUM       NUMBER; -- 교재, 과목 고를 랜덤변수
    V_OC_ID     OPENCOURSE.OC_ID%TYPE;
    V_OC_START  OPENCOURSE.OC_START%TYPE;
    V_PRO_ID    PROFESSOR.PRO_ID%TYPE;
    V_BK_ID     BOOK.BK_ID%TYPE;
    V_SUB_ID    SUBJECT.SUB_ID%TYPE;
BEGIN
    OPEN CUR_OPENCOURSE;
    LOOP
        FETCH CUR_OPENCOURSE INTO V_OC_ID, V_OC_START;
        
        SELECT COUNT(*) INTO V_TEMP
        FROM SUBJECT;
        
        V_TEMP2 := 0;
        
        FOR N IN 1 .. 3 LOOP
            V_NUM    := TRUNC(DBMS_RANDOM.VALUE(1, V_TEMP+1));            
            V_SUB_ID := 'SB'|| LPAD(TO_CHAR(V_NUM), 3, '0');
            V_BK_ID  := 'BK'|| LPAD(TO_CHAR(V_NUM), 3, '0');
            
            SELECT NVL(MAX(PRO_ID), 'NO_DATA') INTO V_PRO_ID
            FROM
            (SELECT PRO_ID
            FROM
               (SELECT PRO_ID
                FROM PROFESSOR
                MINUS
                SELECT PRO_ID
                FROM OPENSUBJECT
                WHERE (OS_START<ADD_MONTHS(V_OC_START, 2*V_TEMP2)       AND ADD_MONTHS(V_OC_START, 2*V_TEMP2)<OS_END)
                   OR (OS_START<ADD_MONTHS(V_OC_START, 2*(V_TEMP2 + 1)) AND ADD_MONTHS(V_OC_START, 2*(V_TEMP2 + 1))<OS_END))
            ORDER BY DBMS_RANDOM.VALUE)
            WHERE ROWNUM=1;
            
            IF(V_PRO_ID = 'NO_DATA')
                THEN V_PRO_ID := ADD_ID('PROFESSOR', 'PRO_ID', 'PR19_000');
                     INSERT INTO PROFESSOR(PRO_ID, PRO_NAME, PRO_SSN, PRO_TEL) VALUES(V_PRO_ID, '임시교수', '999999-9999999', '999-9999-9999');
            END IF;
            
            INSERT INTO OPENSUBJECT(OS_ID, OC_ID, PRO_ID, BK_ID, SUB_ID, OS_START, OS_END)
            VALUES (ADD_ID('OPENSUBJECT', 'OS_ID', 'OS19_0000'), V_OC_ID, V_PRO_ID, V_BK_ID, V_SUB_ID, ADD_MONTHS(V_OC_START, 2*V_TEMP2), ADD_MONTHS(V_OC_START, 2*(V_TEMP2 + 1)));
            
            V_TEMP2 := V_TEMP2 + 1;
        END LOOP;
        
        EXIT WHEN CUR_OPENCOURSE%NOTFOUND;
    END LOOP;
    
    CLOSE CUR_OPENCOURSE;
END;
--==>> Procedure PRC_OPENSUBJECT_SAMPLE이(가) 컴파일되었습니다.

EXEC PRC_OPENSUBJECT_SAMPLE;

SELECT *
FROM OPENSUBJECT;
SELECT *
FROM OPENCOURSE;

--○ 커밋
COMMIT;


CREATE TABLE NAME1
( NAME1 NCHAR(1));
--==>> Table NAME1이(가) 생성되었습니다.

INSERT INTO NAME1 VALUES('권');
INSERT INTO NAME1 VALUES('김');
INSERT INTO NAME1 VALUES('최');
INSERT INTO NAME1 VALUES('유');
INSERT INTO NAME1 VALUES('윤');

INSERT INTO NAME1 VALUES('이');
INSERT INTO NAME1 VALUES('임');
INSERT INTO NAME1 VALUES('전');
INSERT INTO NAME1 VALUES('정');
INSERT INTO NAME1 VALUES('조');

CREATE TABLE NAME2
( NAME2 NCHAR(1));
--==>> Table NAME2이(가) 생성되었습니다.

INSERT INTO NAME2 VALUES('한');
INSERT INTO NAME2 VALUES('경');
INSERT INTO NAME2 VALUES('성');
INSERT INTO NAME2 VALUES('주');
INSERT INTO NAME2 VALUES('진');

INSERT INTO NAME2 VALUES('승');
INSERT INTO NAME2 VALUES('재');
INSERT INTO NAME2 VALUES('지');
INSERT INTO NAME2 VALUES('훈');
INSERT INTO NAME2 VALUES('수');

CREATE TABLE NAME3
( NAME3 NCHAR(1));
--==>> Table NAME3이(가) 생성되었습니다.

INSERT INTO NAME3 VALUES('환');
INSERT INTO NAME3 VALUES('아');
INSERT INTO NAME3 VALUES('희');
INSERT INTO NAME3 VALUES('규');
INSERT INTO NAME3 VALUES('영');

INSERT INTO NAME3 VALUES('혜');
INSERT INTO NAME3 VALUES('연');
INSERT INTO NAME3 VALUES('우');
INSERT INTO NAME3 VALUES('상');
INSERT INTO NAME3 VALUES('원');



CREATE OR REPLACE PROCEDURE PRC_STUDENT_SAMPLE
IS
    CURSOR CUR_NAME
    IS
    SELECT NAME1||NAME2||NAME3 "STU_NAME"
    FROM NAME1, NAME2, NAME3
    ORDER BY DBMS_RANDOM.VALUE;
    
    V_STU_NAME  STUDENT.STU_NAME%TYPE;    
    V_STU_SSN   STUDENT.STU_SSN%TYPE;
    V_STU_TEL   STUDENT.STU_TEL%TYPE;
BEGIN
    OPEN CUR_NAME;
    LOOP
        FETCH CUR_NAME INTO V_STU_NAME;
            V_STU_TEL := FN_MAKE_TEL;
            
            LOOP
                V_STU_SSN := FN_MAKE_SSN;
                EXIT WHEN IS_CONTAIN('STUDENT','STU_SSN',V_STU_SSN)=0;
            END LOOP;
            
            --DBMS_OUTPUT.PUT_LINE(V_STU_NAME||'   '|| V_STU_SSN||'   '|| V_STU_TEL);
           INSERT INTO STUDENT(STU_ID, STU_NAME, STU_SSN, STU_TEL) VALUES(ADD_ID('STUDENT','STU_ID','S19_0000') , V_STU_NAME, V_STU_SSN, V_STU_TEL);
            
        EXIT WHEN CUR_NAME%NOTFOUND;
    END LOOP;
    CLOSE CUR_NAME;
END;
--==>> Procedure PRC_STUDENT_SAMPLE이(가) 컴파일되었습니다.


EXEC PRC_STUDENT_SAMPLE;


CREATE OR REPLACE PROCEDURE PRC_REGISTER_SAMPLE
IS  
    CURSOR CUR_OPENCOURSE
    IS
    SELECT OC_ID, OC_START
    FROM OPENCOURSE;
    
    V_OC_ID     OPENCOURSE.OC_ID%TYPE;
    V_OC_START  OPENCOURSE.OC_START%TYPE;    
    V_ID_NUM    NUMBER;
    V_STU_ID    STUDENT.STU_ID%TYPE;
BEGIN
    V_ID_NUM := 1;
    
    OPEN CUR_OPENCOURSE;
    
    LOOP
        FETCH CUR_OPENCOURSE INTO V_OC_ID, V_OC_START;
        
            DBMS_OUTPUT.PUT_LINE('======================  '||V_OC_ID||'  ======================');
            
            FOR N IN 1 .. 17 LOOP
                SELECT STU_ID INTO V_STU_ID
                FROM STUDENT
                WHERE TO_NUMBER(SUBSTR(STU_ID,5)) = V_ID_NUM;
                
                INSERT INTO REGISTER(REG_ID, STU_ID, OC_ID, REG_DATE) VALUES(ADD_ID('REGISTER','REG_ID','RG19_0000'), V_STU_ID, V_OC_ID, V_OC_START);
                
                V_ID_NUM := V_ID_NUM+1;
            END LOOP;

        EXIT WHEN CUR_OPENCOURSE%NOTFOUND;
    END LOOP;
    
    CLOSE CUR_OPENCOURSE;
    
    EXCEPTION 
        WHEN NO_DATA_FOUND
            THEN DBMS_OUTPUT.PUT_LINE('노데이터 에러');
END;
--==>> Procedure PRC_REGISTER_SAMPLE이(가) 컴파일되었습니다.

EXEC PRC_REGISTER_SAMPLE;


SELECT COUNT(*)
FROM REGISTER
WHERE TO_NUMBER(SUBSTR(STU_ID,5)) >= 562;

SELECT COUNT(*)
FROM REGISTER;

--○ 커밋
COMMIT;




--■■■ 프로시저(PROCEDURE) 생성 ■■■--



CREATE OR REPLACE PROCEDURE PRC_RATIO_SAMPLE
IS
    CURSOR CUR_OPENSUBJECT
    IS
    SELECT OS_ID
    FROM OPENSUBJECT;
    
    V_OS_ID         OPENSUBJECT.OS_ID%TYPE;
    V_ATTENDANCE    RATIO.ATTENDANCE%TYPE;
    V_PERFORMANCE   RATIO.PERFORMANCE%TYPE;
    V_WRITTEN       RATIO.WRITTEN%TYPE;
BEGIN
    OPEN CUR_OPENSUBJECT;
    LOOP
        FETCH CUR_OPENSUBJECT INTO V_OS_ID;
        
        V_ATTENDANCE := ROUND(DBMS_RANDOM.VALUE(20,40), -1);
        V_PERFORMANCE := ROUND(DBMS_RANDOM.VALUE(20,40), -1);
        V_WRITTEN := 100 - V_ATTENDANCE - V_PERFORMANCE;
        
        INSERT INTO RATIO(RATIO_ID, OS_ID, ATTENDANCE, PERFORMANCE, WRITTEN)
        VALUES(SEQ_RATIO.NEXTVAL, V_OS_ID, V_ATTENDANCE, V_PERFORMANCE, V_WRITTEN);
        
        EXIT WHEN CUR_OPENSUBJECT%NOTFOUND;
    END LOOP;
    CLOSE CUR_OPENSUBJECT;
END;
--==>> Procedure PRC_RATIO_SAMPLE이(가) 컴파일되었습니다.

SELECT *
FROM RATIO;

EXEC PRC_RATIO_SAMPLE;


CREATE OR REPLACE PROCEDURE PRC_SCORE_SAMPLE
IS  
    V_OS_ID         OPENSUBJECT.OS_ID%TYPE;
    V_REG_ID        REGISTER.REG_ID%TYPE;
    V_ATTENDANCE    RATIO.ATTENDANCE%TYPE;
    V_PERFORMANCE   RATIO.PERFORMANCE%TYPE;
    V_WRITTEN       RATIO.WRITTEN%TYPE;
    V_OS_END        OPENSUBJECT.OS_END%TYPE;
    V_SC_ID         SCORE.SC_ID%TYPE;
    
    CURSOR  CUR_GET_V
    IS
    SELECT OS.OS_ID, REG.REG_ID, RATIO.ATTENDANCE, RATIO.PERFORMANCE, RATIO.WRITTEN, OS.OS_END
    FROM OPENSUBJECT OS JOIN REGISTER REG ON OS.OC_ID = REG.OC_ID
                        JOIN RATIO        ON OS.OS_ID = RATIO.OS_ID;
BEGIN
    OPEN CUR_GET_V;
    LOOP
        FETCH CUR_GET_V INTO V_OS_ID, V_REG_ID, V_ATTENDANCE, V_PERFORMANCE, V_WRITTEN, V_OS_END;
        
        V_SC_ID := ADD_ID('SCORE', 'SC_ID', 'SC19_0000');    
        
        IF (SYSDATE < V_OS_END)
            THEN DBMS_OUTPUT.PUT_LINE('과목이 끝난 뒤 입력해 주세요');
        ELSE            
            INSERT INTO SCORE(SC_ID, OS_ID, REG_ID, ATTENDANCE, PERFORMANCE, WRITTEN)
            VALUES(V_SC_ID, V_OS_ID, V_REG_ID, TRUNC(DBMS_RANDOM.VALUE(60, 100))*V_ATTENDANCE/100,  TRUNC(DBMS_RANDOM.VALUE(60, 100))*V_PERFORMANCE/100, TRUNC(DBMS_RANDOM.VALUE(60, 100))*V_WRITTEN/100);
        END IF;
                
        EXIT WHEN CUR_GET_V%NOTFOUND;
    END LOOP;
    
    CLOSE CUR_GET_V;
    
    COMMIT;
END;
--==>> Procedure PRC_SCORE_SAMPLE이(가) 컴파일되었습니다.


EXEC PRC_SCORE_SAMPLE;

SELECT *
FROM SCORE
ORDER BY 2 DESC ,1 DESC;

SELECT *
FROM OPENSUBJECT
WHERE OS_END > SYSDATE;
--> 현재일 기준으로 끝나지 않은 과목 52개

SELECT *
FROM OPENSUBJECT;
--> 전체 과목 99개 (33개 과정 * 3개씩)

--○ 커밋
COMMIT;



--■■■ 테이블&컬럼 코멘트(COMMENT) ■■■--



COMMENT ON TABLE ADMIN IS '관리자';
    COMMENT ON COLUMN ADMIN.ADM_ID IS '관리자 ID';
    COMMENT ON COLUMN ADMIN.ADM_PW IS '관리자 PW';

COMMENT ON TABLE BOOK IS '교재';
    COMMENT ON COLUMN BOOK.BK_ID IS '교재코드';
    COMMENT ON COLUMN BOOK.BK_NAME IS '교재명';
    
COMMENT ON TABLE CLASSROOM IS '강의실';
    COMMENT ON COLUMN CLASSROOM.CR_ID IS '강의실코드';
    COMMENT ON COLUMN CLASSROOM.CR_NAME IS '강의실명';
    
COMMENT ON TABLE COURSE IS '과정';    
    COMMENT ON COLUMN COURSE.CS_ID IS '과정코드';
    COMMENT ON COLUMN COURSE.CS_NAME IS '과정명';
    
COMMENT ON TABLE DROPPROFESSOR IS '교수탈퇴';
    COMMENT ON COLUMN DROPPROFESSOR.PRO_ID IS '교수 ID';
    COMMENT ON COLUMN DROPPROFESSOR.DROP_REASON IS '탈퇴사유';
    COMMENT ON COLUMN DROPPROFESSOR.DROP_DATE IS '탈퇴일자';
    COMMENT ON COLUMN DROPPROFESSOR.DROP_PRO_ID IS '탈퇴코드';

COMMENT ON TABLE DROPSTUDENT IS '학생탈퇴';
    COMMENT ON COLUMN DROPSTUDENT.STU_ID IS '학생 ID';
    COMMENT ON COLUMN DROPSTUDENT.DROP_REASON IS '탈퇴사유';
    COMMENT ON COLUMN DROPSTUDENT.DROP_DATE IS '탈퇴일자';
    COMMENT ON COLUMN DROPSTUDENT.DROP_STU_ID IS '탈퇴코드';
    
COMMENT ON TABLE GIVEUP IS '중도포기';
    COMMENT ON COLUMN GIVEUP.REG_ID IS '수강신청코드';
    COMMENT ON COLUMN GIVEUP.GU_DATE IS '중도포기시점';
    COMMENT ON COLUMN GIVEUP.GU_ID IS '중도포기코드';
    
COMMENT ON TABLE LOG_PROFESSOR IS '교수로그인';
    COMMENT ON COLUMN LOG_PROFESSOR.PRO_ID IS '교수 ID';
    COMMENT ON COLUMN LOG_PROFESSOR.PRO_PW IS '교수 PW';

COMMENT ON TABLE LOG_STUDENT IS '학생로그인';
    COMMENT ON COLUMN LOG_STUDENT.STU_ID IS '학생 ID';
    COMMENT ON COLUMN LOG_STUDENT.STU_PW IS '학생 PW';

COMMENT ON TABLE OPENCOURSE IS '개설과정';
    COMMENT ON COLUMN OPENCOURSE.CS_ID IS '과정코드';
    COMMENT ON COLUMN OPENCOURSE.OC_ID IS '개설과정코드';
    COMMENT ON COLUMN OPENCOURSE.CR_ID IS '강의실코드';
    COMMENT ON COLUMN OPENCOURSE.OC_START IS '과정시작';
    COMMENT ON COLUMN OPENCOURSE.OC_END IS '과정끝';
    COMMENT ON COLUMN OPENCOURSE.CAPACITY IS '수강정원';
    
COMMENT ON TABLE OPENSUBJECT IS '개설과목';
    COMMENT ON COLUMN OPENSUBJECT.OC_ID IS '개설과정코드';
    COMMENT ON COLUMN OPENSUBJECT.OS_ID IS '개설과목코드';
    COMMENT ON COLUMN OPENSUBJECT.PRO_ID IS '교수 ID';
    COMMENT ON COLUMN OPENSUBJECT.BK_ID IS '교재코드';
    COMMENT ON COLUMN OPENSUBJECT.SUB_ID IS '과목코드';
    COMMENT ON COLUMN OPENSUBJECT.OS_START IS '과목시작';
    COMMENT ON COLUMN OPENSUBJECT.OS_END IS '과목끝';

COMMENT ON TABLE PROFESSOR IS '교수';
    COMMENT ON COLUMN PROFESSOR.PRO_ID IS '교수 ID';
    COMMENT ON COLUMN PROFESSOR.PRO_NAME IS '교수명';
    COMMENT ON COLUMN PROFESSOR.PRO_SSN IS '주민번호';
    COMMENT ON COLUMN PROFESSOR.PRO_TEL IS '전화번호';

COMMENT ON TABLE RATIO IS '배점';
    COMMENT ON COLUMN RATIO.RATIO_ID IS '배점코드';
    COMMENT ON COLUMN RATIO.OS_ID IS '개설과목코드';
    COMMENT ON COLUMN RATIO.ATTENDANCE IS '출결';
    COMMENT ON COLUMN RATIO.PERFORMANCE IS '실기';
    COMMENT ON COLUMN RATIO.WRITTEN IS '필기';

COMMENT ON TABLE REGISTER IS '수강신청';
    COMMENT ON COLUMN REGISTER.STU_ID IS '학생 ID';
    COMMENT ON COLUMN REGISTER.OC_ID IS '개설과정코드';
    COMMENT ON COLUMN REGISTER.REG_ID IS '수강신청코드';
    COMMENT ON COLUMN REGISTER.REG_DATE IS '수강신청일자';

COMMENT ON TABLE SCORE IS '성적';
    COMMENT ON COLUMN SCORE.OS_ID IS '개설과목코드';
    COMMENT ON COLUMN SCORE.REG_ID IS '수강신청코드';
    COMMENT ON COLUMN SCORE.ATTENDANCE IS '출결';
    COMMENT ON COLUMN SCORE.PERFORMANCE IS '실기';
    COMMENT ON COLUMN SCORE.WRITTEN IS '필기';
    COMMENT ON COLUMN SCORE.SC_ID IS '성적코드';

COMMENT ON TABLE STUDENT IS '학생';
    COMMENT ON COLUMN STUDENT.STU_ID IS '학생 ID';
    COMMENT ON COLUMN STUDENT.STU_NAME IS '학생명';
    COMMENT ON COLUMN STUDENT.STU_SSN IS '주민번호';
    COMMENT ON COLUMN STUDENT.STU_TEL IS '전화번호';
    
COMMENT ON TABLE SUBJECT IS '과목';
    COMMENT ON COLUMN SUBJECT.SUB_ID IS '과목코드';
    COMMENT ON COLUMN SUBJECT.SUB_NAME IS '과목명';






-- ▣ 관리자측 요구분석


-- 1. 시스템 구성 요소

-- 2. 관리자 계정 관련 기능 구현




-- 3. 교수자 계정 관리 기능 구현


-- 3.1 교수자 사전 등록   
    EXEC PRC_PROFESSOR_INSERT(이름, 주민번호, 전화번호);
   
-- 3.1-A) 실행가능구문   
    EXEC PRC_PROFESSOR_INSERT('김철수', '750312-1234567', '010-5305-0506');
   
-- 3.1-B) 주민번호 겹칠 경우
    EXEC PRC_PROFESSOR_INSERT('홍길동', '750312-1234567', '010-3421-2243');
   
-- 3.2 교수자 정보 출력
    SELECT UNIQUE(교수자명),과목명,과목기간,교재명,강의실,강의진행여부
    FROM ALL_STATUS
    ORDER BY 1;
      
-- 3.3 교수자 정보 수정(UPDATE) SQL문
    UPDATE PROFESSOR
    SET PRO_NAME = '입력값', PRO_TEL= '입력값'
    WHERE PRO_ID = '입력값';
    
-- 3.3-A) 실행가능구문
    UPDATE PROFESSOR
    SET PRO_NAME = '홍길동', PRO_TEL= '010-3982-4839'
    WHERE PRO_ID = '홍길동ID';

-- 3.4 교수자 정보 삭제 
    EXEC PRC_DROPPRO_INSERT('교수자ID', '탈퇴사유');

-- 3.4-A) 실행가능구문
    EXEC PRC_DROPPRO_INSERT('홍길동ID', '탈모');
    
-- 3.4-B) 강의중인 교수일 경우
--       (강의중인 교수는 삭제할 수 없습니다. 에러 메세지 출력)
    EXEC PRC_DROPPRO_INSERT('홍길동ID', '안녕히계세요. 여러분. 이 세상의 모든 굴레와 속박을 벗고, 제 행복을 찾아 떠납니다.');

--  3.5 삭제된 교수자 1년뒤 데이터 삭제 SQL문
--  (1년전 삭제되었던 교수 데이터 필요)
    DELETE
    FROM DROPPROFESSOR
    WHERE TRUNC(SYSDATE)-TO_DATE(DROP_DATE, 'YYYY-MM-DD') > 365;

-- 3.5-A) 실행가능구문
    DELETE
    FROM DROPPROFESSOR
    WHERE TRUNC(SYSDATE)-TO_DATE(DROP_DATE, 'YYYY-MM-DD') > 365;



      
-- 4. 과정 관리 기능 구현


-- 4.1 강의장 등록
    INSERT INTO CLASSROOM(CR_ID, CR_NAME)
    VALUES(( SELECT 'CR' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(CR_ID,3))),0)+1), 3, '0') FROM CLASSROOM ), 강의장명);
   
-- 4.1-A) 실행 가능 구문
    INSERT INTO CLASSROOM(CR_ID, CR_NAME)
    VALUES(( SELECT 'CR' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(CR_ID,3))),0)+1), 3, '0') FROM CLASSROOM ), 'G-강의장');

-- 4.2 강의장 정보 수정 
    UPDATE CLASSROOM
    SET CR_NAME = 변경할 강의장명
    WHERE CR_ID = 수정할 강의장코드;

-- 4.2-A) 실행 가능 구문
    UPDATE CLASSROOM
    SET CR_NAME = 'H-강의장'
    WHERE CR_ID = 'CR007';

-- 4.3 강의장 정보 삭제
--     (아예 삭제하는 것이 아니라 강의실명 뒤에 '(사용불가)' 추가 출력)
    UPDATE CLASSROOM
    SET CR_NAME = CR_NAME||'(사용불가)'            
    WHERE CR_ID = 폐쇄된강의실코드;

-- 4.4 아예 사용 불가능하게 할 강의실(폐쇄된)
-- 4.4-A) 실행 가능 구문
--       (아예 삭제하는 것이 아니라 강의실명 뒤에 '(사용불가)' 추가 출력)
    UPDATE CLASSROOM
    SET CR_NAME = CR_NAME||'(사용불가)'             
    WHERE CR_ID = 강의장코드;   

-- 4.5 이미 사용중인 강의장
    SELECT CR_NAME
    FROM CLASSROOM
    WHERE ( SELECT CR_ID
            FROM OPENCOURSE
            WHERE (OC_START<SYSDATE AND SYSDATE<OC_END)
  	       OR (OC_START<ADD_MONTHS(SYSDATE, 6) AND ADD_MONTHS(SYSDATE, 6)<OC_END);	

-- 4.5-A) 실행 가능 구문
    UPDATE CLASSROOM
    SET CR_NAME = CR_NAME||'(사용불가)'     -- 아예 삭제하는 것이 아니라 강의실명 뒤에 '(사용불가)' 추가 출력
    WHERE CR_ID = ‘CR007’;

-- 4.6 사용 가능한 강의장 출력
    SELECT CR_NAME
    FROM CLASSROOM
    MINUS
    SELECT CR_NAME
    FROM CLASSROOM
    WHERE CR_ID IN ( SELECT CR_ID
                     FROM OPENCOURSE
                     WHERE (OC_START<SYSDATE AND SYSDATE<OC_END)
                                OR (OC_START<ADD_MONTHS(SYSDATE, 6) AND         
                                ADD_MONTHS(SYSDATE, 6)<OC_END))
        OR CR_NAME IN (SELECT CR_NAME
                       FROM CLASSROOM
                       WHERE CR_NAME LIKE '%(사용불가)%');

-- 4.7 과정 사전 등록
    INSERT INTO COURSE(CS_ID, CS_NAME)
    VALUES(( SELECT 'CS' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(CS_ID,3))),0)+1), 3, '0') FROM COURSE ), 과정명);

-- 4.7-A) 실행 가능 구문
    INSERT INTO COURSE(CS_ID, CS_NAME)
    VALUES(( SELECT 'CS' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(CS_ID,3))),0)+1), 3, '0') FROM COURSE ), 'JAVA기반의 스마트 웹 앱콘텐츠 양성');

-- 4.8 과정 정보 수정
    UPDATE COURSE
    SET CS_NAME = 변경할 과정명                       
    WHERE CS_ID = 수정할 과정코드;

-- 4.8-A) 실행 가능 구문
    UPDATE COURSE
    SET CS_NAME = 'JAVA기반의 스마트 웹 앱콘텐츠 심화 양성'                          
    WHERE CS_ID = 'CS_ID';

-- 4.9 과정 정보 삭제
-- 4.9-A) 아예 폐강할 과정
--       (아예 삭제하는 것이 아니라 과정명 뒤에 '(수강불가)' 추가 출력)
    UPDATE COURSE
    SET CS_NAME = CS_NAME||'(수강불가)'             
    WHERE CS_ID = 폐강할과정코드;

-- 4.9-A.1) 실행 가능 구문
--         (아예 삭제하는 것이 아니라 과정명 뒤에 '(수강불가)' 추가 출력)
    UPDATE COURSE
    SET CS_NAME = CS_NAME||'(수강불가)'  
    WHERE CS_ID = 'CS007';

-- 4.10 아직 개설하지 않은 과정 중 특정 날짜에 안에 폐강할 과정 삭제
    UPDATE COURSE
    SET CS_NAME = CS_NAME||'(수강불가)' 
    WHERE CS_ID IN ( SELECT CS_ID
                     FROM OPENCOURSE
                     WHERE (OC_START>SYSDATE AND OC_END < 특정날짜);

-- 4.10-A) 실행 가능 구문
    UPDATE COURSE
    SET CS_NAME = CS_NAME||'(수강불가)' 
    WHERE CS_ID IN ( SELECT CS_ID
                     FROM OPENCOURSE
                     WHERE (OC_START>SYSDATE AND OC_END < TO_DATE('2020-01-01')));

-- 4.11 수강 가능한 과정 출력
    SELECT CS_NAME
    FROM COURSE
    MINUS
    SELECT CS_NAME
    FROM COURSE
    WHERE CS_NAME LIKE '%(수강불가)%';

-- 4.12 사용가능한 강의실과 수강가능한 과정 확인 후 개설 과정 입력
    INSERT INTO OPENCOURSE(OC_ID, CS_ID, CR_ID, OC_START, OC_END, CAPACITY) 
    VALUES(( SELECT 'OC'||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||'_'||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(OC_ID,6))), 0 ) + 1), 3, '0') FROM OPENCOURSE )
           , 과정명, 강의실명, 과정시작, 과정끝, 수강인원);

-- 4.12-A) 실행 가능 구문
    INSERT INTO OPENCOURSE(OC_ID, CS_ID, CR_ID, OC_START, OC_END, CAPACITY) 
    VALUES(( SELECT 'OC'||SUBSTR(EXTRACT(YEAR FROM SYSDATE), 3, 2)||'_'||LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(OC_ID,6))), 0 ) + 1), 3, '0') FROM OPENCOURSE )
           , 'CS001', 'CR001' , TO_DATE('2019-08-01', 'YYYY-MM-DD''), TO_DATE('2020-02-30', 'YYYY-MM-DD''), 25);

-- 4.13 개설 과정 정보 수정
    EXEC PRC_OPENCOURSE_UPDATE(수정할개설과정코드, 과정시작, 과정끝, 수강인원);

-- 4.13-A) 실행 가능 구문 (아직 시작 안한 과정)
    EXEC PRC_OPENCOURSE_UPDATE('OC19_035', TO_DATE('2019-07-01', 'YYYY-MM-DD''), TO_DATE('2020-01-31', 'YYYY-MM-DD''), 20);
  
-- 4.13-B) 실행 불가능 구문 (이미 끝난 과정이거나 진행중인 과정) → 에러 발생
    EXEC PRC_OPENCOURSE_UPDATE('OC19_001', TO_DATE('2019-07-01', 'YYYY-MM-DD''), TO_DATE('2020-01-31', 'YYYY-MM-DD''), 20);

-- 4.14 개설 과정 정보 삭제
    DELETE FROM OPENCOURSE WHERE OC_ID = 삭제할개설과정코드;

-- 4.14-A) 실행 가능 구문 (아직 시작하지 않은 개설과정) 
--        (삭제된 개설과정과 관련된 수강신청과 개설과목 데이터도 같이 삭제됨)
    DELETE FROM OPENCOURSE WHERE OC_ID = 'OC19_035';

-- 4.14-B) 실행 불가능 구문 (과정이 현재 진행 중이거나 이미 종료된 과정) → 에러 발생
    DELETE FROM OPENCOURSE WHERE OC_ID = 'OC19_001';

-- 4.15 과정 정보 출력
    SELECT C.CS_NAME"과정명", CR.CR_NAME"강의실", S.SUB_NAME"과목명", OS.OS_START"과목시작", OS.OS_END"과목끝", B.BK_NAME"교재명", PR.PRO_NAME"교수자명" 
    FROM COURSE C, OPENCOURSE OC, CLASSROOM CR, SUBJECT S, OPENSUBJECT OS, BOOK B, PROFESSOR PR
    WHERE OC.CS_ID = C.CS_ID(+)
    AND OC.CR_ID = CR.CR_ID(+)
    AND OC.OC_ID = OS.OC_ID(+)
    AND OS.BK_ID = B.BK_ID(+)
    AND OS.SUB_ID = S.SUB_ID(+)
    AND OS.PRO_ID = PR.PRO_ID(+);




-- 5. 과목 관리 기능 구현


-- 5.1 선택 가능한 교재(삭제되지 않은 교재) 리스트 출력
    SELECT *
    FROM BOOK
    WHERE BK_NAME NOT LIKE '%(삭제)';

-- 5.2 교재 INSERT (웹, 앱에서 BK_NAME을 받아야 함)
    INSERT INTO BOOK(BK_ID, BK_NAME) 
    VALUES( ADD_ID('BOOK','BK_ID','BK000'), '임시교재명');

-- 5.3 교재 UPDATE (웹, 앱에서 BK_ID, BK_NAME을 받아야 함)
--    (BK_ID는 임시로 사용, 여기에 웹, 앱에서 가져온 변수를 담음)
    UPDATE BOOK
    SET BK_NAME = '교재업데이트1'
    WHERE BK_ID = 'BK009'; 

-- 5.4 교재 DELETE
--    (BK_NAME에 '(삭제)'가 없는 튜플의 BK_ID만 고를 수 있게 해둠)
    UPDATE BOOK
    SET BK_NAME = BK_NAME||'(삭제)'
    WHERE BK_ID = 'BK009'; 

-- 5.5 선택 가능한 과목(삭제되지 않은 과목) 리스트 출력
    SELECT *
    FROM SUBJECT
    WHERE SUB_NAME NOT LIKE '%(삭제)';

-- 5.6 과목 INSERT
    INSERT INTO SUBJECT(SUB_ID, SUB_NAME)
    VALUES( ( SELECT 'SB' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(SUB_ID,3))),0)+1), 3, '0') FROM SUBJECT ), '임시과목명');

-- 5.6-A) 참고용 - 번호 뽑는 SUB QUERY문
    SELECT 'SB' || LPAD(TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(SUB_ID,3))),0)+1), 3, '0')
    FROM SUBJECT;

-- 5.7 과목 UPDATE (웹, 앱에서 SUB_ID, SUB_NAME을 받아야 함)
--     (SUB_ID는 임시, 여기에 웹, 앱에서 가져온 변수를 담음)
    UPDATE SUBJECT
    SET SUB_NAME = '과목업데이트1'
    WHERE SUB_ID = 'SB001'; 

-- 5.8 과목 DELETE
    UPDATE SUBJECT
    SET SUB_NAME = SUB_NAME||'(삭제)'
    WHERE SUB_ID = 'SB009';

-- 5.9 특정 날짜에 과목 개설할 때 등록할 수 있는 교수 목록 출력
    SELECT PRO_ID,PRO_NAME
    FROM PROFESSOR
    WHERE PRO_ID IN ( SELECT PRO_ID
    FROM PROFESSOR
    MINUS
    SELECT PRO_ID
    FROM OPENSUBJECT
    WHERE (OS_START<TO_DATE('2019-04-20','YYYY-MM-DD') AND TO_DATE('2019-04-20','YYYY-MM-DD')<OS_END)
       OR (OS_START<TO_DATE('2019-06-20','YYYY-MM-DD') AND TO_DATE('2019-06-20','YYYY-MM-DD')<OS_END));

-- 5.10 개설 과목 INSERT
    EXEC PRC_OPENSUBJECT_INSERT(개설과정코드, 교수번호, 교재코드, 과목코드, 과목시작일, 과목끝일);
    
-- 5.10-A) 실행가능구문
    EXEC PRC_OPENSUBJECT_INSERT('OC_ID', 'PRO_ID', 'BK001', 'SB001', TO_DATE('2019-04-17','YYYY-MM-DD'), TO_DATE('2019-06-17','YYYY-MM-DD'));

-- 5.11 개설 과목 UPDATE
    EXEC PRC_OPENSUBJECT_UPDATE(개설과목코드, 개설과정코드, 교수번호, 교재코드, 과목코드, 과목시작일, 과목끝일);
    
-- 5.11-A) 실행가능구문
    EXEC PRC_OPENSUBJECT_UPDATE('OS_ID','OC_ID', 'PRO_ID', 'BK001', 'SB001', TO_DATE('2019-04-17','YYYY-MM-DD'), TO_DATE('2019-06-17','YYYY-MM-DD'));

-- 5.12 개설 과목 DELETE
    EXEC PRC_OPENSUBJECT_DELETE(개설과목코드);
    
-- 5.12-A) 실행가능구문
    EXEC PRC_OPENSUBJECT_DELETE('OS_ID');

-- 5.13 등록된 모든 과정, 과목 정보 출력
    SELECT UNIQUE(과정명), 강의실, 과목명, 과목기간, 교재명, 교수자명
    FROM ALL_STATUS
    ORDER BY 과목기간;



-- 6. 학생 관리 기능 구현


-- 6.1 학생 데이터 입력
    EXEC PRC_STUDENT_INSERT('이름','주민번호','전화번호');

-- 6.1-A) 학생 데이터 입력 테스트
    EXEC PRC_STUDENT_INSERT('이일이','123456-2111111','010-1111-1111');
    EXEC PRC_STUDENT_INSERT('이이이','123456-2222222','010-2222-2222');
    EXEC PRC_STUDENT_INSERT('이삼이','123456-2333333','010-3333-3333');
    EXEC PRC_STUDENT_INSERT('이사이','123456-2444444','010-4444-4444');

-- 6.1-B) 학생 주민번호 중복 데이터 입력 테스트 
--        → 가입 불가(ORA-20004: 이미 가입한 정보가 존재합니다)
    EXEC PRC_STUDENT_INSERT('테스트','123456-2111111','010-9999-9999');


-- 6.2 탈퇴했다가 다시 가입하는경우
--     → ①STU_ID는 그대로, 정보 변경 ②DROPSTUDENT 에서 해당 STU_ID 레코드가 삭제됨
    EXEC PRC_DROPSTU_INSERT('S19_0601','이유테스트'); -- 탈퇴시킴
    EXEC PRC_STUDENT_INSERT('테스트','123456-2111111','010-9999-9999');
--==>> 학생의 정보변경됨
    SELECT * FROM DROPSTUDENT WHERE STU_ID='S19_0601';
    SELECT * FROM STUDENT WHERE STU_ID='S19_0601';

-- 6.3 등록된 학생 정보 수정
    UPDATE STUDENT
    SET STU_NAME = '변경할 이름', STU_SSN='변경할 주민번호',STU_TEL='변경할 주민번호'
    WHERE STU_ID = '바꿀 대상 STU_ID';

-- 6.4 등록된 학생 정보 수정 데이터
    UPDATE STUDENT
    SET STU_NAME = '이일일', STU_SSN='123456-1111111',STU_TEL='010-0101-0101'
    WHERE STU_ID = 'S19_0001';
    UPDATE STUDENT
    SET STU_NAME = '이이이', STU_SSN='123456-2222222',STU_TEL='010-0202-0202'
    WHERE STU_ID = 'S19_0002';
    UPDATE STUDENT
    SET STU_NAME = '이삼삼', STU_SSN='123456-1333333',STU_TEL='010-0303-0303'
    WHERE STU_ID = 'S19_0003';

-- 6.5 등록된 학생 삭제 (DROPSTUDENT 테이블로 이동)
    EXEC PRC_DROPSTU_INSERT('STU_ID','탈퇴 이유');

-- 6.6 STU_ID는 등록 & REGISTER에 수강신청하지 않은 학생 
--     → 삭제됨
    EXEC PRC_DROPSTU_INSERT('S19_0602','수강신청X/삭제O');
    EXEC PRC_DROPSTU_INSERT('S19_0991','수강신청X/삭제O');

-- 6.7 STU_ID를 등록 & REGISTER에 수강신청한 학생
-- 6.7-A) 수강중인학생 
--       → 삭제되지 않음(에러)
    EXEC PRC_DROPSTU_INSERT('S19_0337','수강중/삭제X');
    EXEC PRC_DROPSTU_INSERT('S19_0338','수강중/삭제X');

-- 6.7-B) 수강중이지 않은 학생 → 삭제됨
-- 6.7-C) 수강전인 학생 → 삭제됨
    EXEC PRC_DROPSTU_INSERT('S19_0447','수강 예정/삭제O');

-- 6.7-C.1) 수강이 끝난 학생 → 삭제됨
    EXEC PRC_DROPSTU_INSERT('S19_0005','수강이 끝남/삭제O');

-- 6.8 DROPSTUDENT 테이블에 있는 데이터 중 1년이 지난 자료 삭제 쿼리문
    DELETE
    FROM DROPSTUDENT
    WHERE MONTHS_BETWEEN(SYSDATE, DROP_DATE) > 12;

-- 6.9 학생 정보 출력 - 이름, 과정명, 수강과목, 총점, 중도포기
    SELECT STU.STU_NAME"학생이름", CS.CS_NAME"과정명", SUB.SUB_NAME"과목명" , SC.ATTENDANCE + SC.PERFORMANCE + SC.WRITTEN "총점"
         ,CASE WHEN (GU_DATE<OS_START) OR (OS_START<GU_DATE AND GU_DATE<OS_END) THEN '중도포기'
          ELSE ' '
          END"중도포기여부"
    FROM REGISTER REG JOIN OPENSUBJECT OS   ON REG.OC_ID = OS.OC_ID
                  LEFT JOIN SCORE SC    ON (REG.REG_ID = SC.REG_ID AND OS.OS_ID = SC.OS_ID)
                  JOIN SUBJECT SUB      ON OS.SUB_ID = SUB.SUB_ID
                  JOIN OPENCOURSE OC    ON OS.OC_ID = OC.OC_ID
                  JOIN STUDENT STU      ON REG.STU_ID = STU.STU_ID
                  JOIN COURSE CS        ON OC.CS_ID = CS.CS_ID
                  LEFT JOIN GIVEUP GU   ON REG.REG_ID = GU.REG_ID
    WHERE STU.STU_ID = 학생코드;

--6.10 중도탈락
    EXEC PRO_GIVEUP_INSERT('중도탈락할학생코드');

--6.10-A) 실행 가능 구문 (현재 수강중인 학생)
    EXEC PRO_GIVEUP_INSERT('');

--6.10-B) 실행 불가능 구문 (이미 수료한 학생이거나 아직 수업예정인 학생)
    EXEC PRO_GIVEUP_INSERT('S19_001');



-- 7. 성적 관리 기능 구현




-- ▣ 교수측 요구분석 

-- 1. 로그인 기능 구현

--1.1 웹 상에서 교수가 로그인을 수행할 때 조회할 테이블 생성
--   (교수ID_를 ID ,주민번호 뒷자리를 PW 로 설정하여 테이블 생성)
    CREATE TABLE LOG_PROFESSOR
    AS
    SELECT PRO_ID"PRO_ID",SUBSTR(PRO_SSN,8)"PRO_PW"
    FROM PROFESSOR;



-- 2. 성적 입력 기능 구현


-- 2.1 배점 입력
    EXEC PRC_RATIO_INSERT(과목코드,출결배점,실기배점,필기배점);
    
-- 2.2 배점수정
    EXEC PRC_RATIO_UPDATE(과목코드,출결배점,실기배점,필기배점);

-- 2.3 성적 입력
    EXEC PRC_SCORE_INSERT(과목코드,학생ID,출결점수,실기점수,필기점수);

-- 2.4 성적 수정
    EXEC PRC_SCORE_UPDATE(과목코드,학생ID,출결점수,실기점수,필기점수);

-- 2.5 성적 삭제
    EXEC PRC_SCORE_DELETE(과목코드,학생ID);


-- 3. 성적 출력 기능 구현
-- 3.1 한 교수의 전체 과목 별 학생 정보 출력
    SELECT 과목명, 과목기간, 교재명, 학생명, 출결, 실기, 필기, 총점, 등수
    FROM ALL_STATUS
    WHERE PRO_ID = 'PR19_001'
    ORDER BY 과목기간, 등수, 학생명;

-- 3.2 한 교수가 가진 과목 전체 출력
    SELECT UNIQUE(OS_ID), 과목명, 과목기간
    FROM ALL_STATUS
    WHERE PRO_ID = 'PR19_001'
    ORDER BY 과목기간;



-- ▣ 학생측 요구분석 

-- 1. 로그인 기능 구현

-- 1.1-A) 웹 상에서 학생이 로그인을 수행할 때 조회할 테이블 생성
--       (학생ID_를 ID ,주민번호 뒷자리를 PW 로 설정하여 테이블 생성)
    CREATE TABLE LOG_STUDENT
    AS
    SELECT STU_ID"학생ID",SUBSTR(STU_SSN,8)"학생PW(주민번호 뒷자리)"
    FROM STUDENT;



-- 2. 성적 출력 기능 구현

-- 2.1-A) 로그인 후 자신이 수강을 끝낸 과목 출력
    SELECT 과정명,과목명,과목기간
    FROM ALL_STATUS
    WHERE SYSDATE >= OS_END AND STU_ID ='S19_0030'
    ORDER BY 과목기간;

-- 2.2-A.1) EX) 내가 수강한 과목 목록
--            과정명              	과목명          과목기간
--    머신러닝 활용 개발 과정	    	HTML		2017-11-23 ~ 2018-01-23  ∇
--    어플리케이션 개발 응용 과정		CSS	    2019-07-09 ~ 2019-09-09  ∇ 
--    머신러닝 활용 개발 과정	    	HTML		2019-12-01 ~ 2020-02-01  ∇  선택

-- 2.3 수강을 끝낸 과목을 선택 시 해당 학생의 성적 출력
    SELECT 학생명, 과정명, 과목명, 과목기간, 교재명, 출결, 실기, 필기, 총점, 등수
    FROM ALL_STATUS
    WHERE SYSDATE >= OS_END AND STU_ID ='S19_0030'
    ORDER BY 과목기간,등수,학생명;

-- 2.3-A) EX) 내가 선택한 과목의 성적
--    학생명          과정명           과목명           과목기간             교재명       출결  실기  필기  총점  등수
--    윤훈희   머신러닝 활용 개발 과정   HTML	   2019-12-01 ~ 2020-02-01   기초부터 HTML    39    20    28	  87    4


-- 2.4 수강신청 기능 구현
-- 2.4-A) 수강신청 가능한 목록 확인하는 쿼리문
    SELECT OC_ID
    FROM OPENCOURSE
    MINUS
    SELECT OC_ID
    FROM 
    (SELECT R.OC_ID,OC.OC_START,OC.OC_END
     FROM REGISTER R JOIN OPENCOURSE OC
                     ON R.OC_ID = OC.OC_ID
    WHERE R.STU_ID = {수강신청하는 학생ID})
    WHERE( OC_START<{수강신청하는 과목의 시작날짜} AND {수강신청하는 과목의 시작날짜}< OC_END) 
          OR (OC_START<{수강신청하는 과목의 끝나는날짜} AND {수강신청하는 과목의 끝나는날짜}< OC_END); 

-- 2.5 수강신청 등록 
--  ★ 개설과목의 수강인원수보다 수강신청한 학생의 수가 더 많으면 수강등록 불가능 (에러발생)

    EXEC PRC_REGISTER_INSERT('STU_ID','OC_ID(개설과정코드)');
-- 아직 시작되지 않은 과정에 수강신청 → 신청 성공
    EXEC PRC_REGISTER_INSERT('S19_0601','OC19_024');
-- 이미 시작된 과정에 수강신청 → 신청 실패
    EXEC PRC_REGISTER_INSERT('S19_0601','OC19_020');
    
-- 2.6 수강신청 삭제 
    EXEC PRC_REGISTER_DELETE('REG_ID(수강신청코드)');
-- 수강신청 취소(신청한 과정이 시작하기 전에) → 취소성공
    EXEC PRC_REGISTER_DELETE('RG19_0409');
-- 수강신청 취소(신청한 과정이 시작한 경우) → 취소불가
    EXEC PRC_REGISTER_DELETE('RG19_0336');
--==>>ORA-20000: 과정이 이미 시작되었을 경우 수강신청을 삭제할 수 없습니다.








